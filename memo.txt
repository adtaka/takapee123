
Access VBAで、先頭フィールドのデータ型を判定するには、DAO.FieldオブジェクトのTypeプロパティを使用します。このプロパティは、そのフィールドのデータ型を示す値を返します。返されるデータ型は、Accessで定義されている定数を使用して表現されます。

先頭項目のデータ型を取得する例
vba
コードをコピーする
Dim db As DAO.Database
Dim tdf As DAO.TableDef
Dim fld As DAO.Field
Dim tableName As String
Dim firstFieldType As Integer

tableName = "テーブル名" ' テーブル名を指定

' データベースを参照
Set db = CurrentDb

' テーブル定義を取得
Set tdf = db.TableDefs(tableName)

' 最初のフィールドのデータ型を取得
firstFieldType = tdf.Fields(0).Type

' データ型を判定し、メッセージボックスに表示
Select Case firstFieldType
    Case dbText
        MsgBox "先頭項目のデータ型は: テキスト型"
    Case dbInteger
        MsgBox "先頭項目のデータ型は: 整数型"
    Case dbLong
        MsgBox "先頭項目のデータ型は: ロング整数型"
    Case dbBoolean
        MsgBox "先頭項目のデータ型は: ブール型"
    Case dbDate
        MsgBox "先頭項目のデータ型は: 日付型"
    Case dbCurrency
        MsgBox "先頭項目のデータ型は: 通貨型"
    ' その他のデータ型もここで追加できます
    Case Else
        MsgBox "先頭項目のデータ型は: 不明"
End Select

' オブジェクトの解放
Set tdf = Nothing
Set db = Nothing


Sub UpdateFieldToNull()
    Dim db As DAO.Database
    Dim sql As String

    ' データベースの参照を取得
    Set db = CurrentDb

    ' UPDATE クエリで NULL を設定
    sql = "UPDATE YourTableName SET YourFieldName = NULL WHERE ConditionField = 'SomeCondition'"

    ' SQL クエリを実行
    db.Execute sql

    ' メッセージ表示（オプション）
    MsgBox "フィールドが NULL に更新されました"

    ' データベースオブジェクトの解放
    Set db = Nothing
End Sub

Sub WriteToSpecificLine()
    Dim fso As Object
    Dim filePath As String
    Dim file As Object
    Dim fileContent As String
    Dim lines() As String
    Dim i As Integer
    Dim targetLine As Integer
    Dim newText As String
    
    ' FileSystemObjectを作成
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    ' ファイルパスを指定
    filePath = "C:\path\to\your\file.txt"
    
    ' 読み込みたい行番号と書き込みたいテキスト
    targetLine = 3  ' 例：3行目を書き換える
    newText = "This is the new content for line 3"
    
    ' ファイルを開いて全内容を読み込む
    Set file = fso.OpenTextFile(filePath, 1)  ' 読み込みモード
    fileContent = file.ReadAll
    file.Close
    
    ' 内容を行ごとに分割して配列に格納
    lines = Split(fileContent, vbCrLf)
    
    ' 指定された行を新しいテキストに書き換える
    If targetLine <= UBound(lines) + 1 Then
        lines(targetLine - 1) = newText
    Else
        MsgBox "指定された行はファイルの行数を超えています。"
        Exit Sub
    End If
    
    ' ファイルを開いて上書き保存する
    Set file = fso.OpenTextFile(filePath, 2)  ' 書き込みモード
    For i = LBound(lines) To UBound(lines)
        file.WriteLine lines(i)
    Next i
    file.Close
    
    MsgBox "指定された行が正常に書き換えられました。"
End Sub


Sub SetFieldRequiredToNo()
    Dim db As DAO.Database
    Dim tdf As DAO.TableDef
    Dim fld As DAO.Field
    
    ' 現在のデータベースを取得
    Set db = CurrentDb
    
    ' テーブル定義を取得（例：Table1）
    Set tdf = db.TableDefs("Table1")
    
    ' 対象のフィールド（例：Field1）の値要求を「いいえ」に設定
    Set fld = tdf.Fields("Field1")
    fld.Required = False  ' 値要求を「いいえ」に設定
    
    ' 変更を保存
    tdf.Fields.Refresh
    MsgBox "Field1 の値要求が「いいえ」に設定されました。"
End Sub


Sub SetAllFieldsRequiredToNo()
    Dim db As DAO.Database
    Dim tdf As DAO.TableDef
    Dim fld As DAO.Field
    
    ' 現在のデータベースを取得
    Set db = CurrentDb
    
    ' テーブル定義を取得（例：Table1）
    Set tdf = db.TableDefs("Table1")
    
    ' テーブル内のすべてのフィールドをループ
    For Each fld In tdf.Fields
        ' フィールドの「値要求」を「いいえ」に設定
        fld.Required = False
    Next fld
    
    ' 変更を保存
    tdf.Fields.Refresh
    MsgBox "すべてのフィールドの値要求が「いいえ」に設定されました。"
End Sub

Sub ExportQueryToCSV()
    Dim db As DAO.Database
    Dim rs As DAO.Recordset
    Dim fso As Object
    Dim txtFile As Object
    Dim filePath As String
    Dim i As Integer
    Dim line As String
    
    ' 出力ファイルのパス
    filePath = "C:\YourFolder\exported_query.csv"
    
    ' データベースとクエリの結果セットを開く
    Set db = CurrentDb
    Set rs = db.OpenRecordset("MyQuery", dbOpenSnapshot)
    
    ' ファイルシステムオブジェクトを作成
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set txtFile = fso.CreateTextFile(filePath, True)
    
    ' ヘッダー行を書き込み
    For i = 0 To rs.Fields.Count - 1
        line = line & rs.Fields(i).Name & ","
    Next i
    ' 最後のカンマを削除して改行
    line = Left(line, Len(line) - 1)
    txtFile.WriteLine line
    
    ' レコードを書き込み
    Do While Not rs.EOF
        line = ""
        For i = 0 To rs.Fields.Count - 1
            line = line & rs.Fields(i).Value & ","
        Next i
        line = Left(line, Len(line) - 1)
        txtFile.WriteLine line
        rs.MoveNext
    Loop
    
    ' リソースの解放
    rs.Close
    Set rs = Nothing
    Set db = Nothing
    txtFile.Close
    Set txtFile = Nothing
    Set fso = Nothing
    
    MsgBox "クエリ結果がCSVファイルにエクスポートされました: " & filePath
End Sub



Sub ExportQueryToCSV_OutputTo()
    Dim filePath As String
    filePath = "C:\YourFolder\exported_query.csv" ' 出力ファイルのパス
    
    ' DoCmd.OutputToを使用してクエリをCSVファイルにエクスポート
    DoCmd.OutputTo acOutputQuery, "MyQuery", acFormatTXT, filePath, True
    
    MsgBox "クエリ結果がCSVファイルにエクスポートされました: " & filePath
End Sub

Sub ExportQueryToPDF()
    Dim filePath As String
    filePath = "C:\YourFolder\exported_query.pdf" ' 出力するPDFファイルのパス
    
    ' DoCmd.OutputToメソッドを使用してクエリをPDFにエクスポート
    DoCmd.OutputTo acOutputQuery, "MyQuery", acFormatPDF, filePath, True
    
    MsgBox "クエリ結果がPDFファイルにエクスポートされました: " & filePath
End Sub

Sub CreateQueryAndExportToPDF()
    Dim db As DAO.Database
    Dim qdf As DAO.QueryDef
    Dim sqlStr As String
    Dim filePath As String
    
    ' データベースオブジェクトの取得
    Set db = CurrentDb
    
    ' クエリのSQL文を作成 (必要に応じてSQL文を変更)
    sqlStr = "SELECT Field1, Field2, Field3 FROM YourTable WHERE SomeCondition = True"
    
    ' 既存のクエリがあれば削除
    On Error Resume Next
    db.QueryDefs.Delete "TempQuery"
    On Error GoTo 0
    
    ' クエリ定義を作成
    Set qdf = db.CreateQueryDef("TempQuery", sqlStr)
    
    ' PDFファイルの保存場所を指定
    filePath = "C:\YourFolder\query_output.pdf"
    
    ' クエリをPDFにエクスポート
    DoCmd.OutputTo acOutputQuery, "TempQuery", acFormatPDF, filePath, True
    
    MsgBox "クエリ結果がPDFファイルにエクスポートされました: " & filePath
    
    ' リソースの解放
    Set qdf = Nothing
    Set db = Nothing
End Sub

Sub CreateQueryAndExportToPDF()
    Dim db As DAO.Database
    Dim qdf As DAO.QueryDef
    Dim sqlStr As String
    Dim filePath As String
    
    ' データベースオブジェクトの取得
    Set db = CurrentDb
    
    ' クエリのSQL文を作成 (必要に応じてSQL文を変更)
    sqlStr = "SELECT Field1, Field2, Field3 FROM YourTable WHERE SomeCondition = True"
    
    ' 既存のクエリがあれば削除
    On Error Resume Next
    db.QueryDefs.Delete "TempQuery"
    On Error GoTo 0
    
    ' クエリ定義を作成
    Set qdf = db.CreateQueryDef("TempQuery", sqlStr)
    
    ' PDFファイルの保存場所を指定
    filePath = "C:\YourFolder\query_output.pdf"
    
    ' クエリをPDFにエクスポート
    DoCmd.OutputTo acOutputQuery, "TempQuery", acFormatPDF, filePath, True
    
    MsgBox "クエリ結果がPDFファイルにエクスポートされました: " & filePath
    
    ' リソースの解放
    Set qdf = Nothing
    Set db = Nothing
End Sub




Sub ExportQueryToCSV_TransferText()
    Dim filePath As String
    filePath = "C:\YourFolder\exported_query.csv" ' 出力ファイルのパス
    
    ' DoCmd.TransferTextを使用してクエリをCSVファイルにエクスポート
    DoCmd.TransferText acExportDelim, , "MyQuery", filePath, True
    
    MsgBox "クエリ結果がCSVファイルにエクスポートされました: " & filePath
End Sub


Sub ExportAndDeleteIni()
    Dim filePath As String
    Dim fso As Object
    Dim iniFilePath As String
    
    ' CSVファイルの保存場所を指定
    filePath = "C:\YourFolder\exported_query.csv"
    
    ' DoCmd.TransferTextメソッドでクエリをCSVにエクスポート
    DoCmd.TransferText acExportDelim, , "MyQuery", filePath, True
    
    ' export.iniファイルのパス
    iniFilePath = "C:\YourFolder\export.ini"
    
    ' ファイルシステムオブジェクトを使ってexport.iniを削除
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    ' export.iniが存在する場合に削除
    If fso.FileExists(iniFilePath) Then
        fso.DeleteFile iniFilePath
    End If
    
    MsgBox "クエリ結果がCSVファイルにエクスポートされ、export.iniファイルは削除されました。"
    
    ' リソースの解放
    Set fso = Nothing
End Sub


Sub DeleteAllFilesInFolder()
    Dim fso As Object
    Dim folderPath As String
    Dim folder As Object
    Dim file As Object
    
    ' 削除したいフォルダーのパスを指定
    folderPath = "C:\YourFolder\"
    
    ' FileSystemObjectを作成
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    ' フォルダーが存在するか確認
    If fso.FolderExists(folderPath) Then
        ' フォルダー内のすべてのファイルを取得
        Set folder = fso.GetFolder(folderPath)
        
        ' フォルダー内の各ファイルを削除
        For Each file In folder.Files
            file.Delete
        Next file
        
        MsgBox "フォルダー内のすべてのファイルが削除されました: " & folderPath
    Else
        MsgBox "指定されたフォルダーは存在しません: " & folderPath
    End If
    
    ' リソースの解放
    Set folder = Nothing
    Set fso = Nothing
End Sub




Sub ConcatenateAllFields()
    Dim db As DAO.Database
    Dim rs As DAO.Recordset
    Dim fld As DAO.Field
    Dim sql As String
    Dim tableName As String
    Dim concatenatedFields As String
    
    tableName = "Table1" ' テーブル名を指定
    concatenatedFields = ""

    ' データベースを取得
    Set db = CurrentDb
    
    ' テーブルのフィールド名を取得
    Set rs = db.OpenRecordset(tableName)
    
    ' フィールドをすべて連結
    For Each fld In rs.Fields
        If concatenatedFields <> "" Then
            concatenatedFields = concatenatedFields & " & ', ' & "
        End If
        concatenatedFields = concatenatedFields & "[" & fld.Name & "]"
    Next fld
    
    ' SQL文を作成
    sql = "SELECT " & concatenatedFields & " AS ConcatenatedFields FROM " & tableName & ";"
    
    ' SQL文を出力（または実行）
    Debug.Print sql
    ' DoCmd.RunSQL sql ' 実行する場合
    
    rs.Close
    Set rs = Nothing
    Set db = Nothing
End Sub



Dim db As DAO.Database
Dim rs As DAO.Recordset
Dim sql As String

sql = "SELECT Table1.ItemID, Table1.OtherField1, Table2.OtherField2 " & _
      "FROM Table1 " & _
      "INNER JOIN Table2 ON Table1.ItemID = Table2.ItemID;"

Set db = CurrentDb
Set rs = db.OpenRecordset(sql)

' 結果を操作するコード
Do While Not rs.EOF
    Debug.Print rs!ItemID & ", " & rs!OtherField1 & ", " & rs!OtherField2
    rs.MoveNext
Loop

rs.Close
Set rs = Nothing
Set db = Nothing




Sub GetFieldCount()
    Dim db As DAO.Database
    Dim tdf As DAO.TableDef
    Dim fldCount As Integer
    
    ' 現在のデータベースを取得
    Set db = CurrentDb
    
    ' テーブルの TableDef オブジェクトを取得 (例: "MyTable" がテーブル名)
    Set tdf = db.TableDefs("MyTable")
    
    ' テーブルのフィールド数を取得
    fldCount = tdf.Fields.Count
    
    ' 結果を表示
    MsgBox "フィールドの数: " & fldCount
End Sub

Sub ConcatenateAllFields()
    Dim db As DAO.Database
    Dim rs As DAO.Recordset
    Dim fld As DAO.Field
    Dim sql As String
    Dim tableName As String
    Dim concatenatedFields As String
    
    tableName = "Table1" ' テーブル名を指定
    concatenatedFields = ""

    ' データベースを取得
    Set db = CurrentDb
    
    ' テーブルのフィールド名を取得
    Set rs = db.OpenRecordset(tableName)
    
    ' フィールドをすべて連結
    For Each fld In rs.Fields
        If concatenatedFields <> "" Then
            concatenatedFields = concatenatedFields & " & ', ' & "
        End If
        concatenatedFields = concatenatedFields & "Nz([" & fld.Name & "], '')"
    Next fld
    
    ' SQL文を作成
    sql = "SELECT " & concatenatedFields & " AS ConcatenatedFields FROM " & tableName & ";"
    
    ' SQL文を出力（または実行）
    Debug.Print sql
    ' DoCmd.RunSQL sql ' 実行する場合
    
    rs.Close
    Set rs = Nothing
    Set db = Nothing
End Sub



Sub CompareAllFieldsInTables()
    Dim db As DAO.Database
    Dim rsA As DAO.Recordset
    Dim rsB As DAO.Recordset
    Dim fld As DAO.Field
    Dim sqlA As String
    Dim sqlB As String
    Dim matchFound As Boolean
    Dim i As Integer
    Dim diffCount As Integer

    Set db = CurrentDb
    
    ' テーブルAから全てのレコードを取得
    sqlA = "SELECT * FROM テーブルA"
    Set rsA = db.OpenRecordset(sqlA)
    
    ' テーブルBのレコードをIDで検索
    Do While Not rsA.EOF
        sqlB = "SELECT * FROM テーブルB WHERE ID = " & rsA!ID
        Set rsB = db.OpenRecordset(sqlB)
        
        If Not rsB.EOF Then
            matchFound = True
            diffCount = 0
            
            ' すべてのフィールドをループして比較
            For i = 0 To rsA.Fields.Count - 1
                Set fld = rsA.Fields(i)
                
                ' IDフィールドはスキップ（すでに一致で検索しているため）
                If fld.Name <> "ID" Then
                    If rsA.Fields(i).Value <> rsB.Fields(i).Value Then
                        Debug.Print "ID " & rsA!ID & " の " & fld.Name & " が異なります: " & rsA.Fields(i).Value & " vs " & rsB.Fields(i).Value
                        matchFound = False
                        diffCount = diffCount + 1
                    End If
                End If
            Next i
            
            If matchFound Then
                Debug.Print "ID " & rsA!ID & " のレコードは全て一致します。"
            Else
                Debug.Print "ID " & rsA!ID & " のレコードは " & diffCount & " 個のフィールドが異なります。"
            End If
        Else
            Debug.Print "ID " & rsA!ID & " はテーブルBに存在しません。"
        End If
        
        rsA.MoveNext
    Loop
    
    ' クリーンアップ
    rsA.Close
    rsB.Close
    Set rsA = Nothing
    Set rsB = Nothing
    Set db = Nothing
End Sub


Function ConvertSecondsToTime(seconds As Long) As String
    Dim hours As Long
    Dim minutes As Long
    Dim secs As Long
    
    ' 時間、分、秒を計算
    hours = seconds \ 3600
    minutes = (seconds Mod 3600) \ 60
    secs = seconds Mod 60
    
    ' 結果をフォーマットして返す
    ConvertSecondsToTime = Format(hours, "00") & ":" & Format(minutes, "00") & ":" & Format(secs, "00")
End Function



Dim myDict As Object
Set myDict = CreateObject("Scripting.Dictionary")

' アイテムの追加
myDict.Add "Fruit1", "Apple"
myDict.Add "Fruit2", "Banana"
myDict.Add "Fruit3", "Cherry"

' Dictionaryの内容をループで表示
Dim key As Variant
For Each key In myDict.Keys
    Debug.Print key & ": " & myDict(key)
Next key



Sub CreateTableInAccessWithErrorHandling()
    On Error GoTo ErrorHandler
    Dim db As DAO.Database
    Dim tbl As DAO.TableDef
    Dim fld As DAO.Field

    ' 現在のデータベースを開く
    Set db = CurrentDb
    
    ' 新しいテーブルを作成
    Set tbl = db.CreateTableDef("MyNewTable")
    
    ' フィールドをテーブルに追加
    Set fld = tbl.CreateField("ID", dbLong)
    tbl.Fields.Append fld
    
    Set fld = tbl.CreateField("Name", dbText, 50)
    tbl.Fields.Append fld
    
    Set fld = tbl.CreateField("BirthDate", dbDate)
    tbl.Fields.Append fld
    
    ' テーブルをデータベースに追加
    db.TableDefs.Append tbl
    
    MsgBox "テーブルが作成されました!"
    
    ' オブジェクトの解放
    Set fld = Nothing
    Set tbl = Nothing
    Set db = Nothing
    Exit Sub
    
ErrorHandler:
    MsgBox "エラーが発生しました: " & Err.Description
End Sub

Sub ExportTableToExcelUsingTransferSpreadsheet()
    Dim strPath As String
    strPath = "C:\path\to\your\file.xlsx" ' エクスポートするファイルのパスを指定
    
    ' AccessテーブルをExcelにエクスポート
    DoCmd.TransferSpreadsheet acExport, acSpreadsheetTypeExcel12Xml, "TableName", strPath, True
End Sub




' FileSystemObject を使ってフォルダ内のファイル名を取得するスクリプト

Dim folderPath
folderPath = "C:\Your\Folder\Path" ' フォルダのパスを指定

Dim fso, folder, file
Set fso = CreateObject("Scripting.FileSystemObject")
Set folder = fso.GetFolder(folderPath)

' ファイルを列挙する
For Each file In folder.Files
    WScript.Echo file.Name
Next

' オブジェクトを解放
Set folder = Nothing
Set fso = Nothing


' Access ファイルからテーブル名を取得するスクリプト

Dim accessApp, dbPath, db
dbPath = "C:\Your\Access\Database.accdb" ' Access データベースのパスを指定

' Access アプリケーションオブジェクトを作成
Set accessApp = CreateObject("Access.Application")

' データベースを開く
accessApp.OpenCurrentDatabase dbPath

' データベースのテーブルコレクションにアクセス
Set db = accessApp.CurrentDb

Dim tableDef
For Each tableDef In db.TableDefs
    ' システムテーブルは除外 (MSys で始まるテーブルはシステムテーブル)
    If Left(tableDef.Name, 4) <> "MSys" Then
        WScript.Echo tableDef.Name
    End If
Next

' Access アプリケーションを閉じる
accessApp.CloseCurrentDatabase
accessApp.Quit

' オブジェクトの解放
Set db = Nothing
Set accessApp = Nothing


Sub ExportTableDefinitionsToExcel()
    Dim db As DAO.Database
    Dim tbl As DAO.TableDef
    Dim fld As DAO.Field
    Dim excelApp As Object
    Dim workbook As Object
    Dim worksheet As Object
    Dim row As Integer
    Dim filePath As String
    
    ' Excelアプリケーションのインスタンスを作成
    Set excelApp = CreateObject("Excel.Application")
    excelApp.Visible = True
    
    ' 新しいワークブックを作成
    Set workbook = excelApp.Workbooks.Add
    
    ' 現在のデータベースを取得
    Set db = CurrentDb
    
    ' テーブルをループ
    For Each tbl In db.TableDefs
        ' システムテーブルを除外するための条件
        If Left(tbl.Name, 4) <> "MSys" Then
            ' 新しいワークシートを作成
            Set worksheet = workbook.Sheets.Add
            worksheet.Name = tbl.Name
            
            ' ヘッダ行を書き込み
            worksheet.Cells(1, 1).Value = "Field Name"
            worksheet.Cells(1, 2).Value = "Data Type"
            worksheet.Cells(1, 3).Value = "Field Size"
            
            ' 行インデックスの初期化
            row = 2
            
            ' テーブルのフィールドをループ
            For Each fld In tbl.Fields
                worksheet.Cells(row, 1).Value = fld.Name
                worksheet.Cells(row, 2).Value = FieldTypeName(fld.Type)
                worksheet.Cells(row, 3).Value = fld.Size
                row = row + 1
            Next fld
        End If
    Next tbl
    
    ' ファイルパスを設定し、Excelファイルを保存
    filePath = Application.CurrentProject.Path & "\TableDefinitions.xlsx"
    workbook.SaveAs filePath
    
    ' クリーンアップ
    workbook.Close
    excelApp.Quit
    Set workbook = Nothing
    Set excelApp = Nothing
    Set fld = Nothing
    Set tbl = Nothing
    Set db = Nothing
    
    MsgBox "テーブル定義がエクセルファイルにエクスポートされました: " & filePath
End Sub

' データ型を名前に変換する関数
Function FieldTypeName(typeCode As Integer) As String
    Select Case typeCode
        Case dbBoolean
            FieldTypeName = "Boolean"
        Case dbByte
            FieldTypeName = "Byte"
        Case dbInteger
            FieldTypeName = "Integer"
        Case dbLong
            FieldTypeName = "Long"
        Case dbCurrency
            FieldTypeName = "Currency"
        Case dbSingle
            FieldTypeName = "Single"
        Case dbDouble
            FieldTypeName = "Double"
        Case dbDate
            FieldTypeName = "Date/Time"
        Case dbText
            FieldTypeName = "Text"
        Case dbMemo
            FieldTypeName = "Memo"
        Case dbGUID
            FieldTypeName = "GUID"
        Case dbBinary
            FieldTypeName = "Binary"
        Case dbLongBinary
            FieldTypeName = "OLE Object"
        Case dbVarBinary
            FieldTypeName = "VarBinary"
        Case dbBigInt
            FieldTypeName = "BigInt"
        Case dbNumeric
            FieldTypeName = "Numeric"
        Case Else
            FieldTypeName = "Unknown"
    End Select
End Function




Sub ExportAllAccessTableDefinitionsToExcel()
    Dim fso As Object
    Dim folder As Object
    Dim file As Object
    Dim db As DAO.Database
    Dim tbl As DAO.TableDef
    Dim fld As DAO.Field
    Dim idx As DAO.Index
    Dim excelApp As Object
    Dim workbook As Object
    Dim worksheet As Object
    Dim row As Integer
    Dim folderPath As String
    Dim filePath As String
    Dim fieldRequired As Boolean
    Dim fieldIndexed As Boolean
    Dim isPrimaryKey As Boolean
    
    ' エクスポート先のExcelアプリケーションのインスタンスを作成
    Set excelApp = CreateObject("Excel.Application")
    excelApp.Visible = True
    Set workbook = excelApp.Workbooks.Add
    
    ' フォルダパスを設定
    folderPath = "C:\指定フォルダパス" ' ここを変更してください
    
    ' ファイルシステムオブジェクト(FSO)を使ってフォルダ内のファイルを取得
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set folder = fso.GetFolder(folderPath)
    
    ' フォルダ内のすべてのファイルをループ
    For Each file In folder.Files
        ' Accessファイル（.accdb または .mdb）かどうか確認
        If LCase(fso.GetExtensionName(file.Name)) = "accdb" Or LCase(fso.GetExtensionName(file.Name)) = "mdb" Then
            ' 各ファイルのフルパス
            filePath = folderPath & "\" & file.Name
            
            ' Accessファイルを開く
            Set db = DBEngine.OpenDatabase(filePath)
            
            ' テーブルをループ
            For Each tbl In db.TableDefs
                ' システムテーブルを除外するための条件
                If Left(tbl.Name, 4) <> "MSys" Then
                    ' 新しいワークシートを作成
                    Set worksheet = workbook.Sheets.Add
                    worksheet.Name = tbl.Name & "_" & file.Name
                    
                    ' ヘッダ行を書き込み
                    worksheet.Cells(1, 1).Value = "Field Name"
                    worksheet.Cells(1, 2).Value = "Data Type"
                    worksheet.Cells(1, 3).Value = "Field Size"
                    worksheet.Cells(1, 4).Value = "Required"
                    worksheet.Cells(1, 5).Value = "Indexed"
                    worksheet.Cells(1, 6).Value = "Primary Key"
                    
                    ' 行インデックスの初期化
                    row = 2
                    
                    ' テーブルのフィールドをループ
                    For Each fld In tbl.Fields
                        ' フィールド名、データ型、フィールドサイズを書き込み
                        worksheet.Cells(row, 1).Value = fld.Name
                        worksheet.Cells(row, 2).Value = FieldTypeName(fld.Type)
                        worksheet.Cells(row, 3).Value = fld.Size
                        
                        ' 必須フィールドかどうか
                        fieldRequired = fld.Required
                        worksheet.Cells(row, 4).Value = IIf(fieldRequired, "Yes", "No")
                        
                        ' インデックスの有無とプライマリキーのチェック
                        fieldIndexed = False
                        isPrimaryKey = False
                        For Each idx In tbl.Indexes
                            If idx.Fields(0).Name = fld.Name Then
                                fieldIndexed = True
                                If idx.Primary Then
                                    isPrimaryKey = True
                                End If
                            End If
                        Next idx
                        worksheet.Cells(row, 5).Value = IIf(fieldIndexed, "Yes", "No")
                        worksheet.Cells(row, 6).Value = IIf(isPrimaryKey, "Yes", "No")
                        
                        ' 行を次に移動
                        row = row + 1
                    Next fld
                End If
            Next tbl
            
            ' Accessデータベースを閉じる
            db.Close
            Set db = Nothing
        End If
    Next file
    
    ' Excelファイルの保存
    filePath = folderPath & "\AllTableDefinitions.xlsx"
    workbook.SaveAs filePath
    
    ' クリーンアップ
    workbook.Close
    excelApp.Quit
    Set workbook = Nothing
    Set excelApp = Nothing
    Set fld = Nothing
    Set tbl = Nothing
    Set fso = Nothing
    Set folder = Nothing
    
    MsgBox "すべてのAccessファイルのテーブル定義がエクスポートされました: " & filePath
End Sub

' データ型を名前に変換する関数
Function FieldTypeName(typeCode As Integer) As String
    Select Case typeCode
        Case dbBoolean
            FieldTypeName = "Boolean"
        Case dbByte
            FieldTypeName = "Byte"
        Case dbInteger
            FieldTypeName = "Integer"
        Case dbLong
            FieldTypeName = "Long"
        Case dbCurrency
            FieldTypeName = "Currency"
        Case dbSingle
            FieldTypeName = "Single"
        Case dbDouble
            FieldTypeName = "Double"
        Case dbDate
            FieldTypeName = "Date/Time"
        Case dbText
            FieldTypeName = "Text"
        Case dbMemo
            FieldTypeName = "Memo"
        Case dbGUID
            FieldTypeName = "GUID"
        Case dbBinary
            FieldTypeName = "Binary"
        Case dbLongBinary
            FieldTypeName = "OLE Object"
        Case dbVarBinary
            FieldTypeName = "VarBinary"
        Case dbBigInt
            FieldTypeName = "BigInt"
        Case dbNumeric
            FieldTypeName = "Numeric"
        Case Else
            FieldTypeName = "Unknown"
    End Select
End Function


Sub ExportAllPrimaryKeysToExcel()
    Dim fso As Object
    Dim folder As Object
    Dim file As Object
    Dim db As DAO.Database
    Dim tbl As DAO.TableDef
    Dim idx As DAO.Index
    Dim fld As DAO.Field
    Dim excelApp As Object
    Dim workbook As Object
    Dim worksheet As Object
    Dim row As Integer
    Dim folderPath As String
    Dim filePath As String
    
    ' エクスポート先のExcelアプリケーションのインスタンスを作成
    Set excelApp = CreateObject("Excel.Application")
    excelApp.Visible = True
    Set workbook = excelApp.Workbooks.Add
    
    ' 新しいワークシートを作成
    Set worksheet = workbook.Sheets.Add
    worksheet.Name = "PrimaryKeys"
    
    ' ヘッダ行を書き込み
    worksheet.Cells(1, 1).Value = "File Name"
    worksheet.Cells(1, 2).Value = "Table Name"
    worksheet.Cells(1, 3).Value = "Primary Key Field"
    
    ' 行インデックスの初期化
    row = 2
    
    ' フォルダパスを設定
    folderPath = "C:\指定フォルダパス" ' ここを指定するフォルダパスに変更してください
    
    ' ファイルシステムオブジェクト(FSO)を使ってフォルダ内のファイルを取得
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set folder = fso.GetFolder(folderPath)
    
    ' フォルダ内のすべてのファイルをループ
    For Each file In folder.Files
        ' Accessファイル（.accdb または .mdb）かどうか確認
        If LCase(fso.GetExtensionName(file.Name)) = "accdb" Or LCase(fso.GetExtensionName(file.Name)) = "mdb" Then
            ' 各ファイルのフルパス
            filePath = folderPath & "\" & file.Name
            
            ' Accessファイルを開く
            Set db = DBEngine.OpenDatabase(filePath)
            
            ' テーブルをループ
            For Each tbl In db.TableDefs
                ' システムテーブルを除外するための条件
                If Left(tbl.Name, 4) <> "MSys" Then
                    ' インデックスをループしてプライマリキーを確認
                    For Each idx In tbl.Indexes
                        If idx.Primary Then
                            ' プライマリキーのフィールド名をループしてExcelに出力
                            For Each fld In idx.Fields
                                worksheet.Cells(row, 1).Value = file.Name
                                worksheet.Cells(row, 2).Value = tbl.Name
                                worksheet.Cells(row, 3).Value = fld.Name
                                row = row + 1
                            Next fld
                        End If
                    Next idx
                End If
            Next tbl
            
            ' Accessデータベースを閉じる
            db.Close
            Set db = Nothing
        End If
    Next file
    
    ' Excelファイルの保存
    filePath = folderPath & "\PrimaryKeysList.xlsx"
    workbook.SaveAs filePath
    
    ' クリーンアップ
    workbook.Close
    excelApp.Quit
    Set workbook = Nothing
    Set excelApp = Nothing
    Set fld = Nothing
    Set tbl = Nothing
    Set fso = Nothing
    Set folder = Nothing
    
    MsgBox "すべてのプライマリキーの項目がエクスポートされました: " & filePath
End Sub




Sub ExportAllAccessTableDefinitionsToExcel()
    Dim fso As Object
    Dim folder As Object
    Dim file As Object
    Dim db As DAO.Database
    Dim tbl As DAO.TableDef
    Dim fld As DAO.Field
    Dim idx As DAO.Index
    Dim excelApp As Object
    Dim workbook As Object
    Dim worksheet As Object
    Dim row As Integer
    Dim folderPath As String
    Dim filePath As String
    Dim fieldRequired As Boolean
    Dim fieldIndexed As Boolean
    Dim isPrimaryKey As Boolean
    
    ' エクスポート先のExcelアプリケーションのインスタンスを作成
    Set excelApp = CreateObject("Excel.Application")
    excelApp.Visible = True
    Set workbook = excelApp.Workbooks.Add
    
    ' フォルダパスを設定
    folderPath = "C:\指定フォルダパス" ' ここを変更してください
    
    ' ファイルシステムオブジェクト(FSO)を使ってフォルダ内のファイルを取得
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set folder = fso.GetFolder(folderPath)
    
    ' フォルダ内のすべてのファイルをループ
    For Each file In folder.Files
        ' Accessファイル（.accdb または .mdb）かどうか確認
        If LCase(fso.GetExtensionName(file.Name)) = "accdb" Or LCase(fso.GetExtensionName(file.Name)) = "mdb" Then
            ' 各ファイルのフルパス
            filePath = folderPath & "\" & file.Name
            
            ' Accessファイルを開く
            Set db = DBEngine.OpenDatabase(filePath)
            
            ' テーブルをループ
            For Each tbl In db.TableDefs
                ' システムテーブルを除外するための条件
                If Left(tbl.Name, 4) <> "MSys" Then
                    ' 新しいワークシートを作成
                    Set worksheet = workbook.Sheets.Add
                    worksheet.Name = tbl.Name & "_" & file.Name
                    
                    ' ヘッダ行を書き込み
                    worksheet.Cells(1, 1).Value = "Field Name"
                    worksheet.Cells(1, 2).Value = "Data Type"
                    worksheet.Cells(1, 3).Value = "Field Size"
                    worksheet.Cells(1, 4).Value = "Required"
                    worksheet.Cells(1, 5).Value = "Indexed"
                    worksheet.Cells(1, 6).Value = "Primary Key"
                    
                    ' 行インデックスの初期化
                    row = 2
                    
                    ' テーブルのフィールドをループ
                    For Each fld In tbl.Fields
                        ' フィールド名、データ型、フィールドサイズを書き込み
                        worksheet.Cells(row, 1).Value = fld.Name
                        worksheet.Cells(row, 2).Value = FieldTypeName(fld.Type)
                        worksheet.Cells(row, 3).Value = fld.Size
                        
                        ' 必須フィールドかどうか
                        fieldRequired = fld.Required
                        worksheet.Cells(row, 4).Value = IIf(fieldRequired, "Yes", "No")
                        
                        ' インデックスの有無とプライマリキーのチェック
                        fieldIndexed = False
                        isPrimaryKey = False
                        
                        ' インデックスをループしてプライマリキーを確認
                        For Each idx In tbl.Indexes
                            If idx.Primary Then ' プライマリキーインデックスか確認
                                Dim i As Integer
                                For i = 0 To idx.Fields.Count - 1
                                    If idx.Fields(i).Name = fld.Name Then
                                        isPrimaryKey = True ' 該当フィールドがプライマリキー
                                    End If
                                Next i
                            End If
                        Next idx
                        
                        worksheet.Cells(row, 5).Value = IIf(fieldIndexed, "Yes", "No")
                        worksheet.Cells(row, 6).Value = IIf(isPrimaryKey, "Yes", "No")
                        
                        ' 行を次に移動
                        row = row + 1
                    Next fld
                End If
            Next tbl
            
            ' Accessデータベースを閉じる
            db.Close
            Set db = Nothing
        End If
    Next file
    
    ' Excelファイルの保存
    filePath = folderPath & "\AllTableDefinitionsWithPrimaryKey.xlsx"
    workbook.SaveAs filePath
    
    ' クリーンアップ
    workbook.Close
    excelApp.Quit
    Set workbook = Nothing
    Set excelApp = Nothing
    Set fld = Nothing
    Set tbl = Nothing
    Set fso = Nothing
    Set folder = Nothing
    
    MsgBox "すべてのAccessファイルのテーブル定義がエクスポートされました: " & filePath
End Sub

' データ型を名前に変換する関数
Function FieldTypeName(typeCode As Integer) As String
    Select Case typeCode
        Case dbBoolean
            FieldTypeName = "Boolean"
        Case dbByte
            FieldTypeName = "Byte"
        Case dbInteger
            FieldTypeName = "Integer"
        Case dbLong
            FieldTypeName = "Long"
        Case dbCurrency
            FieldTypeName = "Currency"
        Case dbSingle
            FieldTypeName = "Single"
        Case dbDouble
            FieldTypeName = "Double"
        Case dbDate
            FieldTypeName = "Date/Time"
        Case dbText
            FieldTypeName = "Text"
        Case dbMemo
            FieldTypeName = "Memo"
        Case dbGUID
            FieldTypeName = "GUID"
        Case dbBinary
            FieldTypeName = "Binary"
        Case dbLongBinary
            FieldTypeName = "OLE Object"
        Case dbVarBinary
            FieldTypeName = "VarBinary"
        Case dbBigInt
            FieldTypeName = "BigInt"
        Case dbNumeric
            FieldTypeName = "Numeric"
        Case Else
            FieldTypeName = "Unknown"
    End Select
End Function

Sub ExportAllTableAttributesToExcel()
    Dim fso As Object
    Dim folder As Object
    Dim file As Object
    Dim db As DAO.Database
    Dim tbl As DAO.TableDef
    Dim fld As DAO.Field
    Dim idx As DAO.Index
    Dim excelApp As Object
    Dim workbook As Object
    Dim worksheet As Object
    Dim row As Integer
    Dim folderPath As String
    Dim filePath As String
    Dim fieldRequired As Boolean
    Dim fieldIndexed As Boolean
    Dim isPrimaryKey As Boolean
    Dim fieldDescription As String
    Dim fieldDefaultValue As String
    Dim fieldValidationRule As String
    Dim fieldFormat As String
    
    ' エクスポート先のExcelアプリケーションのインスタンスを作成
    Set excelApp = CreateObject("Excel.Application")
    excelApp.Visible = True
    Set workbook = excelApp.Workbooks.Add
    
    ' フォルダパスを設定
    folderPath = "C:\指定フォルダパス" ' ここを指定するフォルダパスに変更してください
    
    ' ファイルシステムオブジェクト(FSO)を使ってフォルダ内のファイルを取得
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set folder = fso.GetFolder(folderPath)
    
    ' フォルダ内のすべてのファイルをループ
    For Each file In folder.Files
        ' Accessファイル（.accdb または .mdb）かどうか確認
        If LCase(fso.GetExtensionName(file.Name)) = "accdb" Or LCase(fso.GetExtensionName(file.Name)) = "mdb" Then
            ' 各ファイルのフルパス
            filePath = folderPath & "\" & file.Name
            
            ' Accessファイルを開く
            Set db = DBEngine.OpenDatabase(filePath)
            
            ' テーブルをループ
            For Each tbl In db.TableDefs
                ' システムテーブルを除外するための条件
                If Left(tbl.Name, 4) <> "MSys" Then
                    ' 新しいワークシートを作成
                    Set worksheet = workbook.Sheets.Add
                    worksheet.Name = tbl.Name & "_" & file.Name
                    
                    ' ヘッダ行を書き込み
                    worksheet.Cells(1, 1).Value = "Field Name"
                    worksheet.Cells(1, 2).Value = "Data Type"
                    worksheet.Cells(1, 3).Value = "Field Size"
                    worksheet.Cells(1, 4).Value = "Required"
                    worksheet.Cells(1, 5).Value = "Indexed"
                    worksheet.Cells(1, 6).Value = "Primary Key"
                    worksheet.Cells(1, 7).Value = "Description"
                    worksheet.Cells(1, 8).Value = "Default Value"
                    worksheet.Cells(1, 9).Value = "Validation Rule"
                    worksheet.Cells(1, 10).Value = "Format"
                    
                    ' 行インデックスの初期化
                    row = 2
                    
                    ' テーブルのフィールドをループ
                    For Each fld In tbl.Fields
                        ' フィールド名、データ型、フィールドサイズを書き込み
                        worksheet.Cells(row, 1).Value = fld.Name
                        worksheet.Cells(row, 2).Value = FieldTypeName(fld.Type)
                        worksheet.Cells(row, 3).Value = fld.Size
                        
                        ' 必須フィールドかどうか
                        fieldRequired = fld.Required
                        worksheet.Cells(row, 4).Value = IIf(fieldRequired, "Yes", "No")
                        
                        ' インデックスの有無とプライマリキーのチェック
                        fieldIndexed = False
                        isPrimaryKey = False
                        
                        ' インデックスをループしてプライマリキーを確認
                        For Each idx In tbl.Indexes
                            If idx.Primary Then ' プライマリキーインデックスか確認
                                Dim i As Integer
                                For i = 0 To idx.Fields.Count - 1
                                    If idx.Fields(i).Name = fld.Name Then
                                        isPrimaryKey = True ' 該当フィールドがプライマリキー
                                    End If
                                Next i
                            End If
                        Next idx
                        
                        worksheet.Cells(row, 5).Value = IIf(fieldIndexed, "Yes", "No")
                        worksheet.Cells(row, 6).Value = IIf(isPrimaryKey, "Yes", "No")
                        
                        ' フィールドの説明
                        On Error Resume Next
                        fieldDescription = fld.Properties("Description")
                        worksheet.Cells(row, 7).Value = fieldDescription
                        On Error GoTo 0
                        
                        ' フィールドの既定値
                        On Error Resume Next
                        fieldDefaultValue = fld.DefaultValue
                        worksheet.Cells(row, 8).Value = fieldDefaultValue
                        On Error GoTo 0
                        
                        ' フィールドの検証ルール
                        On Error Resume Next
                        fieldValidationRule = fld.ValidationRule
                        worksheet.Cells(row, 9).Value = fieldValidationRule
                        On Error GoTo 0
                        
                        ' フィールドのフォーマット
                        On Error Resume Next
                        fieldFormat = fld.Format
                        worksheet.Cells(row, 10).Value = fieldFormat
                        On Error GoTo 0
                        
                        ' 行を次に移動
                        row = row + 1
                    Next fld
                End If
            Next tbl
            
            ' Accessデータベースを閉じる
            db.Close
            Set db = Nothing
        End If
    Next file
    
    ' Excelファイルの保存
    filePath = folderPath & "\AllTableDefinitionsWithAttributes.xlsx"
    workbook.SaveAs filePath
    
    ' クリーンアップ
    workbook.Close
    excelApp.Quit
    Set workbook = Nothing
    Set excelApp = Nothing
    Set fld = Nothing
    Set tbl = Nothing
    Set fso = Nothing
    Set folder = Nothing
    
    MsgBox "すべてのAccessファイルのテーブル定義がエクスポートされました: " & filePath
End Sub

' データ型を名前に変換する関数
Function FieldTypeName(typeCode As Integer) As String
    Select Case typeCode
        Case dbBoolean
            FieldTypeName = "Boolean"
        Case dbByte
            FieldTypeName = "Byte"
        Case dbInteger
            FieldTypeName = "Integer"
        Case dbLong
            FieldTypeName = "Long"
        Case dbCurrency
            FieldTypeName = "Currency"
        Case dbSingle
            FieldTypeName = "Single"
        Case dbDouble
            FieldTypeName = "Double"
        Case dbDate
            FieldTypeName = "Date/Time"
        Case dbText
            FieldTypeName = "Text"
        Case dbMemo
            FieldTypeName = "Memo"
        Case dbGUID
            FieldTypeName = "GUID"
        Case dbBinary
            FieldTypeName = "Binary"
        Case dbLongBinary
            FieldTypeName = "OLE Object"
        Case dbVarBinary
            FieldTypeName = "VarBinary"
        Case dbBigInt
            FieldTypeName = "BigInt"
        Case dbNumeric
            FieldTypeName = "Numeric"
        Case Else
            FieldTypeName = "Unknown"
    End Select
End Function






Sub ExportTableDefinitionsToAccess()
    Dim fso As Object
    Dim folder As Object
    Dim file As Object
    Dim db As DAO.Database
    Dim tbl As DAO.TableDef
    Dim fld As DAO.Field
    Dim idx As DAO.Index
    Dim rs As DAO.Recordset
    Dim dbCurrent As DAO.Database
    Dim folderPath As String
    Dim filePath As String
    Dim fieldRequired As Boolean
    Dim fieldIndexed As Boolean
    Dim isPrimaryKey As Boolean
    Dim fieldDescription As String
    Dim fieldDefaultValue As String
    Dim fieldValidationRule As String
    Dim fieldFormat As String
    
    ' 現在のデータベース（保存先）を取得
    Set dbCurrent = CurrentDb
    
    ' 新しいテーブルを作成
    On Error Resume Next
    dbCurrent.Execute "DROP TABLE TableDefinitions" ' 既存のテーブルがあれば削除
    On Error GoTo 0
    
    dbCurrent.Execute "CREATE TABLE TableDefinitions (" & _
                      "FileName TEXT(255), " & _
                      "TableName TEXT(255), " & _
                      "FieldName TEXT(255), " & _
                      "DataType TEXT(50), " & _
                      "FieldSize LONG, " & _
                      "Required YESNO, " & _
                      "Indexed YESNO, " & _
                      "PrimaryKey YESNO, " & _
                      "Description TEXT(255), " & _
                      "DefaultValue TEXT(255), " & _
                      "ValidationRule TEXT(255), " & _
                      "Format TEXT(255))"
    
    ' テーブル定義情報を保存するためのレコードセットを開く
    Set rs = dbCurrent.OpenRecordset("TableDefinitions", dbOpenDynaset)
    
    ' フォルダパスを設定
    folderPath = "C:\指定フォルダパス" ' ここを指定するフォルダパスに変更してください
    
    ' ファイルシステムオブジェクト(FSO)を使ってフォルダ内のファイルを取得
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set folder = fso.GetFolder(folderPath)
    
    ' フォルダ内のすべてのファイルをループ
    For Each file In folder.Files
        ' Accessファイル（.accdb または .mdb）かどうか確認
        If LCase(fso.GetExtensionName(file.Name)) = "accdb" Or LCase(fso.GetExtensionName(file.Name)) = "mdb" Then
            ' 各ファイルのフルパス
            filePath = folderPath & "\" & file.Name
            
            ' Accessファイルを開く
            Set db = DBEngine.OpenDatabase(filePath)
            
            ' テーブルをループ
            For Each tbl In db.TableDefs
                ' システムテーブルを除外するための条件
                If Left(tbl.Name, 4) <> "MSys" Then
                    ' テーブルのフィールドをループ
                    For Each fld In tbl.Fields
                        ' フィールド属性を取得
                        fieldRequired = fld.Required
                        fieldDescription = ""
                        fieldDefaultValue = ""
                        fieldValidationRule = ""
                        fieldFormat = ""
                        
                        ' エラー回避のためのエラーハンドリング
                        On Error Resume Next
                        fieldDescription = fld.Properties("Description")
                        fieldDefaultValue = fld.DefaultValue
                        fieldValidationRule = fld.ValidationRule
                        fieldFormat = fld.Format
                        On Error GoTo 0
                        
                        ' インデックスとプライマリキーの確認
                        fieldIndexed = False
                        isPrimaryKey = False
                        
                        For Each idx In tbl.Indexes
                            If idx.Primary Then
                                Dim i As Integer
                                For i = 0 To idx.Fields.Count - 1
                                    If idx.Fields(i).Name = fld.Name Then
                                        isPrimaryKey = True
                                    End If
                                Next i
                            End If
                        Next idx
                        
                        ' レコードを追加
                        rs.AddNew
                        rs!FileName = file.Name
                        rs!TableName = tbl.Name
                        rs!FieldName = fld.Name
                        rs!DataType = FieldTypeName(fld.Type)
                        rs!FieldSize = fld.Size
                        rs!Required = fieldRequired
                        rs!Indexed = fieldIndexed
                        rs!PrimaryKey = isPrimaryKey
                        rs!Description = fieldDescription
                        rs!DefaultValue = fieldDefaultValue
                        rs!ValidationRule = fieldValidationRule
                        rs!Format = fieldFormat
                        rs.Update
                    Next fld
                End If
            Next tbl
            
            ' Accessデータベースを閉じる
            db.Close
            Set db = Nothing
        End If
    Next file
    
    ' クリーンアップ
    rs.Close
    Set rs = Nothing
    Set dbCurrent = Nothing
    Set fso = Nothing
    Set folder = Nothing
    
    MsgBox "すべてのAccessファイルのテーブル定義がAccessに保存されました。"
End Sub

' データ型を名前に変換する関数
Function FieldTypeName(typeCode As Integer) As String
    Select Case typeCode
        Case dbBoolean
            FieldTypeName = "Boolean"
        Case dbByte
            FieldTypeName = "Byte"
        Case dbInteger
            FieldTypeName = "Integer"
        Case dbLong
            FieldTypeName = "Long"
        Case dbCurrency
            FieldTypeName = "Currency"
        Case dbSingle
            FieldTypeName = "Single"
        Case dbDouble
            FieldTypeName = "Double"
        Case dbDate
            FieldTypeName = "Date/Time"
        Case dbText
            FieldTypeName = "Text"
        Case dbMemo
            FieldTypeName = "Memo"
        Case dbGUID
            FieldTypeName = "GUID"
        Case dbBinary
            FieldTypeName = "Binary"
        Case dbLongBinary
            FieldTypeName = "OLE Object"
        Case dbVarBinary
            FieldTypeName = "VarBinary"
        Case dbBigInt
            FieldTypeName = "BigInt"
        Case dbNumeric
            FieldTypeName = "Numeric"
        Case Else
            FieldTypeName = "Unknown"
    End Select
End Function

機密度ラベルのVBAでの直接適用は難しい
VBAだけで機密度ラベルを適用することは現在のところ難しいですが、Microsoftの他のツールやAPI、Power Automateなどを組み合わせることで、ある程度の自動化や保護が可能です。

Sub ExportTableUsingTransferSpreadsheet()
    Dim strExcelPath As String
    strExcelPath = "C:\Users\YourUsername\Documents\ExportedData.xlsx"  ' エクスポート先のパス

    ' DoCmd.TransferSpreadsheetを使用して、テーブルをExcelにエクスポート
    DoCmd.TransferSpreadsheet acExport, acSpreadsheetTypeExcel12Xml, "YourTableName", strExcelPath, True

    MsgBox "テーブルがExcelにエクスポートされました！", vbInformation
End Sub


「秘密度ラベル選択画面を回避する」要件は、一般的にOffice製品（Word、Excel、Outlookなど）や他の情報保護システムで使われている「秘密度ラベル」機能に関連している可能性があります。この機能は、Microsoft Information Protection（MIP）や他の情報保護ツールによって提供され、データのセキュリティとコンプライアンスを強化するために使用されます。

特定のドキュメントやメールに秘密度ラベルを自動的に適用したり、選択を促すポップアップを無効にしたりするための方法について説明します。

1. 自動ラベル適用ルールの構成
管理者がラベルの適用を自動化するルールを設定することで、ユーザーが手動でラベルを選択する必要がなくなります。Microsoft 365の情報保護機能や、他のセキュリティ管理コンソールで以下のような設定を行います。

ポリシーの自動化: 特定の条件に応じて（例えば、ファイルに機密情報が含まれている場合）、自動的に秘密度ラベルを適用するルールを設定します。これにより、ユーザーにポップアップが表示されることを避けられます。
管理者設定: 管理者権限がある場合、Microsoft 365の「情報保護」センターで秘密度ラベルの設定を見直し、手動選択を回避できるようにします。
2. ラベル適用の無効化（ユーザー側で回避）
ユーザーが秘密度ラベルの選択画面を回避するためには、以下のアプローチを取ることができます。

ラベルなしのドキュメント作成: 新しいドキュメントやメール作成時にラベルを適用しないオプションがある場合、それを選択してラベル適用をスキップすることができます。
オートラベルポップアップの無効化（管理者による設定）: ラベルを強制的に選ばせるポップアップが表示されないようにするには、管理者がOfficeアプリケーションのポリシー設定でポップアップを無効化することが可能です。
Outlookでの手動ラベル設定の無効化
Outlookなどで秘密度ラベル選択を促すメッセージが頻繁に表示される場合は、Outlookのオプション設定でラベル適用を無効にすることができます。具体的には、以下の操作を行います。

Outlookを開く
ファイル -> オプション -> メール を選択
情報保護 セクションで、ラベルの選択を無効にするオプションがあればオフにします（企業や管理者によって設定されている場合、個々のユーザーは変更できないことがあります）。
3. Officeアドインの無効化
もし秘密度ラベルの選択画面がOfficeのアドイン機能によって表示されている場合は、そのアドインを無効化することも選択肢の一つです。以下の手順でアドインを無効にできます。

Officeアプリを開く（Word、Excel、Outlookなど）
ファイル -> オプション -> アドイン
管理 ボタンを押し、表示されたアドイン一覧で該当するセキュリティやラベル関連のアドインを無効化
4. グループポリシーを使用した制御（IT管理者向け）
企業内で秘密度ラベルを自動で設定しつつ、手動のラベル選択をユーザーに強制したくない場合、グループポリシー（GPO）を使ってポリシーを制御できます。

Microsoft 365情報保護: 管理者がGPOを使用して、Officeアプリケーションでラベル選択画面の表示を管理します。これにより、ユーザーが手動でラベルを選択するプロセスを省略できる場合があります。



Sub ExportTableUsingTransferSpreadsheet()
    Dim strExcelPath As String
    strExcelPath = "C:\Users\YourUsername\Documents\ExportedData.xlsx"  ' エクスポート先のパス

    ' DoCmd.TransferSpreadsheetを使用して、テーブルをExcelにエクスポート
    DoCmd.TransferSpreadsheet acExport, acSpreadsheetTypeExcel12Xml, "YourTableName", strExcelPath, True

    MsgBox "テーブルがExcelにエクスポートされました！", vbInformation
End Sub


Sub ExportTableWithSheetName()
    Dim strExcelPath As String
    Dim objExcel As Object
    Dim objWorkbook As Object

    ' エクスポートするExcelファイルのパスを指定
    strExcelPath = "C:\Users\YourUsername\Documents\ExportedData.xlsx"
    
    ' DoCmd.TransferSpreadsheetでAccessテーブルをエクスポート
    DoCmd.TransferSpreadsheet acExport, acSpreadsheetTypeExcel12Xml, "YourTableName", strExcelPath, True

    ' Excelを起動し、エクスポートされたファイルを開く
    Set objExcel = CreateObject("Excel.Application")
    Set objWorkbook = objExcel.Workbooks.Open(strExcelPath)

    ' シート名を変更する（テーブル名のシートを探して名前を変更）
    objWorkbook.Sheets("YourTableName").Name = "NewSheetName"

    ' Excelファイルを保存して閉じる
    objWorkbook.Save
    objWorkbook.Close
    objExcel.Quit

    ' メモリ解放
    Set objWorkbook = Nothing
    Set objExcel = Nothing

    MsgBox "テーブルが指定のシート名でエクスポートされました！", vbInformation
End Sub



Sub ExportTableToExcel()
    Dim objExcel As Object
    Dim objWorkbook As Object
    Dim db As DAO.Database
    Dim rs As DAO.Recordset
    Dim strExcelPath As String
    Dim i As Integer

    ' エクスポートするExcelファイルのパス
    strExcelPath = "C:\Users\YourUsername\Documents\ExportedData.xlsx"
    
    ' Excelアプリケーションを起動
    Set objExcel = CreateObject("Excel.Application")
    Set objWorkbook = objExcel.Workbooks.Add

    ' Accessデータベースとテーブルを開く
    Set db = CurrentDb
    Set rs = db.OpenRecordset("YourTableName")  ' ここにテーブル名を指定
    
    ' フィールド名をExcelに書き込む
    For i = 0 To rs.Fields.Count - 1
        objWorkbook.Sheets(1).Cells(1, i + 1).Value = rs.Fields(i).Name
    Next i

    ' レコードをExcelに書き込む
    i = 2 ' データの開始行を指定（フィールド名の次の行）
    Do Until rs.EOF
        For j = 0 To rs.Fields.Count - 1
            objWorkbook.Sheets(1).Cells(i, j + 1).Value = rs.Fields(j).Value
        Next j
        i = i + 1
        rs.MoveNext
    Loop

    ' Excelファイルを保存
    objWorkbook.SaveAs strExcelPath

    ' Excelを閉じる
    objWorkbook.Close
    objExcel.Quit

    ' メモリ解放
    Set rs = Nothing
    Set db = Nothing
    Set objWorkbook = Nothing
    Set objExcel = Nothing
    
    MsgBox "テーブルのデータがExcelにエクスポートされました！", vbInformation
End Sub


Sub RunModuleFromAnotherDatabase()
    ' 別のAccessデータベースファイルを開く
    Dim accApp As Object
    Set accApp = CreateObject("Access.Application")
    
    ' 別のAccessファイルのパス
    accApp.OpenCurrentDatabase "C:\Path\To\AnotherDatabase.accdb"
    
    ' モジュールの関数を実行
    accApp.Run "ModuleName.FunctionName"
    
    ' データベースを閉じる
    accApp.Quit
    Set accApp = Nothing
End Sub


Sub ExportTableToExcel()
    ' 変数の宣言
    Dim xlApp As Object
    Dim xlBook As Object
    Dim xlSheet As Object
    Dim rs As DAO.Recordset
    Dim i As Integer
    Dim filePath As String
    Dim tableName As String
    
    ' Excelファイルのパス
    filePath = "C:\path\to\your\file.xlsx"  ' 既存のExcelファイルのパスに置き換える
    ' エクスポートするAccessのテーブル名
    tableName = "YourTableName"  ' テーブル名を指定
    
    ' Excelアプリケーションを起動
    Set xlApp = CreateObject("Excel.Application")
    ' 既存のExcelブックを開く
    Set xlBook = xlApp.Workbooks.Open(filePath)
    ' 新しいシートを追加
    Set xlSheet = xlBook.Sheets.Add
    xlSheet.Name = "AccessData"  ' シート名を変更（必要に応じて）
    
    ' レコードセットを取得
    Set rs = CurrentDb.OpenRecordset(tableName)
    
    ' フィールド名をExcelの1行目に書き込む
    For i = 0 To rs.Fields.Count - 1
        xlSheet.Cells(1, i + 1).Value = rs.Fields(i).Name
    Next i
    
    ' レコードセットのデータをExcelに書き込む
    i = 2  ' 2行目からデータを書き込む
    Do While Not rs.EOF
        For j = 0 To rs.Fields.Count - 1
            xlSheet.Cells(i, j + 1).Value = rs.Fields(j).Value
        Next j
        rs.MoveNext
        i = i + 1
    Loop
    
    ' Excelファイルを保存して閉じる
    xlBook.Save
    xlBook.Close
    xlApp.Quit
    
    ' オブジェクトの解放
    Set rs = Nothing
    Set xlSheet = Nothing
    Set xlBook = Nothing
    Set xlApp = Nothing
    
    MsgBox "データのエクスポートが完了しました！"
End Sub


Sub CreateEmptyExcelFile()
    Dim ws As Worksheet
    
    ' すべてのシートを削除
    Application.DisplayAlerts = False
    For Each ws In ThisWorkbook.Worksheets
        ws.Delete
    Next ws
    Application.DisplayAlerts = True
    
    ' 空のシートを追加
    Worksheets.Add

    ' ファイルを保存
    Dim savePath As String
    savePath = Application.GetSaveAsFilename(FileFilter:="Excel Files (*.xlsx), *.xlsx")
    
    If savePath <> "False" Then
        ThisWorkbook.SaveAs Filename:=savePath, FileFormat:=xlOpenXMLWorkbook
    End If
End Sub


Sub RemoveSheetsFromExistingFile()
    Dim ws As Worksheet
    Dim wb As Workbook
    Dim filePath As String
    
    ' ファイルを選択して開くダイアログ
    filePath = Application.GetOpenFilename(FileFilter:="Excel Files (*.xlsx), *.xlsx")
    
    If filePath = "False" Then
        MsgBox "ファイルが選択されませんでした。"
        Exit Sub
    End If
    
    ' 選択したファイルを開く
    Set wb = Workbooks.Open(filePath)
    
    ' すべてのシートを削除（少なくとも1枚はシートが残る）
    Application.DisplayAlerts = False
    For Each ws In wb.Worksheets
        ws.Delete
    Next ws
    Application.DisplayAlerts = True
    
    ' 空のシートを追加
    wb.Worksheets.Add
    
    ' 上書き保存
    wb.Save
    
    ' ブックを閉じる
    wb.Close
    
    MsgBox "すべてのシートを削除し、空のシートで保存しました。"
End Sub



Sub RemoveSheetsFromExcel()
    Dim xlApp As Object
    Dim xlBook As Object
    Dim xlSheet As Object
    Dim filePath As String
    
    ' Excelアプリケーションを起動
    On Error Resume Next
    Set xlApp = CreateObject("Excel.Application")
    On Error GoTo 0
    
    If xlApp Is Nothing Then
        MsgBox "Excelがインストールされていません。"
        Exit Sub
    End If
    
    ' Excelを表示しない（バックグラウンドで動作）
    xlApp.Visible = False
    
    ' ファイルを選択するダイアログを表示
    filePath = Application.FileDialog(3).Show
    
    ' ファイルが選択されていない場合は終了
    If filePath = 0 Then
        MsgBox "ファイルが選択されませんでした。"
        xlApp.Quit
        Set xlApp = Nothing
        Exit Sub
    End If
    
    ' 選択したExcelファイルを開く
    Set xlBook = xlApp.Workbooks.Open(Application.FileDialog(3).SelectedItems(1))
    
    ' すべてのシートを削除（少なくとも1枚はシートが残る）
    xlApp.DisplayAlerts = False
    For Each xlSheet In xlBook.Worksheets
        xlSheet.Delete
    Next xlSheet
    xlApp.DisplayAlerts = True
    
    ' 空のシートを追加
    xlBook.Worksheets.Add
    
    ' 上書き保存
    xlBook.Save
    
    ' ファイルを閉じる
    xlBook.Close
    
    ' Excelを終了
    xlApp.Quit
    
    ' オブジェクトを解放
    Set xlSheet = Nothing
    Set xlBook = Nothing
    Set xlApp = Nothing
    
    MsgBox "Excelファイルのシートを削除し、空のシートで保存しました。"
End Sub




Sub ファイルコピー()
    Dim 元ファイル As String
    Dim コピー先 As String
    
    ' 元のファイルのパスを指定
    元ファイル = "C:\Users\YourName\Documents\元のファイル.xlsx"
    
    ' コピー先のファイルのパスを指定
    コピー先 = "C:\Users\YourName\Documents\コピーされたファイル.xlsx"
    
    ' ファイルをコピー
    FileCopy 元ファイル, コピー先
    
    MsgBox "ファイルのコピーが完了しました！"
End Sub

Sub AddSheetWithName()
    Dim sheetName As String
    sheetName = InputBox("新しいシートの名前を入力してください:", "シートの追加")
    
    ' シートが既に存在するか確認
    Dim ws As Worksheet
    On Error Resume Next
    Set ws = ThisWorkbook.Sheets(sheetName)
    On Error GoTo 0
    
    If Not ws Is Nothing Then
        MsgBox "シート '" & sheetName & "' は既に存在します。"
    Else
        ' 新しいシートを作成し、指定した名前を設定
        ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.Count)).Name = sheetName
        MsgBox "新しいシート '" & sheetName & "' が追加されました。"
    End If
End Sub


Sub ExportTableToExcel()
    ' 変数の宣言
    Dim xlApp As Object
    Dim xlBook As Object
    Dim xlSheet As Object
    Dim rs As DAO.Recordset
    Dim i As Integer
    Dim filePath As String
    Dim tableName As String
    
    ' Excelファイルのパス
    filePath = "C:\path\to\your\file.xlsx"  ' 既存のExcelファイルのパスに置き換える
    ' エクスポートするAccessのテーブル名
    tableName = "YourTableName"  ' テーブル名を指定
    
    ' Excelアプリケーションを起動
    Set xlApp = CreateObject("Excel.Application")
    ' 既存のExcelブックを開く
    Set xlBook = xlApp.Workbooks.Open(filePath)
    ' 新しいシートを追加
    Set xlSheet = xlBook.Sheets.Add
    xlSheet.Name = "AccessData"  ' シート名を変更（必要に応じて）
    
    ' レコードセットを取得
    Set rs = CurrentDb.OpenRecordset(tableName)
    
    ' フィールド名をExcelの1行目に書き込む
    For i = 0 To rs.Fields.Count - 1
        xlSheet.Cells(1, i + 1).Value = rs.Fields(i).Name
    Next i
    
    ' レコードセットのデータをExcelに書き込む
    i = 2  ' 2行目からデータを書き込む
    Do While Not rs.EOF
        For j = 0 To rs.Fields.Count - 1
            xlSheet.Cells(i, j + 1).Value = rs.Fields(j).Value
        Next j
        rs.MoveNext
        i = i + 1
    Loop
    
    ' Excelファイルを保存して閉じる
    xlBook.Save
    xlBook.Close
    xlApp.Quit
    
    ' オブジェクトの解放
    Set rs = Nothing
    Set xlSheet = Nothing
    Set xlBook = Nothing
    Set xlApp = Nothing
    
    MsgBox "データのエクスポートが完了しました！"
End Sub


Sub FastExportTableToExcel()
    ' 変数の宣言
    Dim xlApp As Object
    Dim xlBook As Object
    Dim xlSheet As Object
    Dim rs As DAO.Recordset
    Dim i As Integer, j As Integer
    Dim filePath As String
    Dim tableName As String
    Dim dataArray() As Variant
    Dim fieldCount As Integer
    Dim rowCount As Integer
    
    ' Excelファイルのパス
    filePath = "C:\path\to\your\file.xlsx"  ' 既存のExcelファイルのパスに置き換える
    ' エクスポートするAccessのテーブル名
    tableName = "YourTableName"  ' テーブル名を指定
    
    ' Excelアプリケーションを起動
    Set xlApp = CreateObject("Excel.Application")
    ' 既存のExcelブックを開く
    Set xlBook = xlApp.Workbooks.Open(filePath)
    ' 新しいシートを追加
    Set xlSheet = xlBook.Sheets.Add
    xlSheet.Name = "AccessData"  ' シート名を変更（必要に応じて）

    ' レコードセットを取得
    Set rs = CurrentDb.OpenRecordset(tableName)
    
    ' フィールド数とレコード数を取得
    fieldCount = rs.Fields.Count
    rs.MoveLast
    rowCount = rs.RecordCount
    rs.MoveFirst
    
    ' データを配列に格納（フィールド名を含む）
    ReDim dataArray(0 To rowCount, 0 To fieldCount - 1)
    
    ' フィールド名を配列の最初の行に格納
    For i = 0 To fieldCount - 1
        dataArray(0, i) = rs.Fields(i).Name
    Next i
    
    ' データを配列に格納
    i = 1 ' 配列の2行目からデータを入れる
    Do While Not rs.EOF
        For j = 0 To fieldCount - 1
            dataArray(i, j) = rs.Fields(j).Value
        Next j
        rs.MoveNext
        i = i + 1
    Loop
    
    ' Excelの更新を停止して速度を向上
    xlApp.ScreenUpdating = False
    
    ' 配列を一括でExcelに書き込む
    xlSheet.Range(xlSheet.Cells(1, 1), xlSheet.Cells(rowCount + 1, fieldCount)).Value = dataArray
    
    ' Excelファイルを保存して閉じる
    xlBook.Save
    xlBook.Close
    xlApp.ScreenUpdating = True
    xlApp.Quit
    
    ' オブジェクトの解放
    Set rs = Nothing
    Set xlSheet = Nothing
    Set xlBook = Nothing
    Set xlApp = Nothing
    
    MsgBox "データのエクスポートが完了しました！"
End Sub


Sub GetDataFromTextFileUsingFSO()
    Dim fso As Object
    Dim ts As Object
    Dim FilePath As String
    Dim LineNumber As Long
    Dim StartChar As Long
    Dim CharLength As Long
    Dim LineContent As String
    Dim Result As String
    Dim CurrentLine As Long
    
    ' FilePathにテキストファイルのパスを設定
    FilePath = "C:\path\to\your\file.txt" ' 適切なファイルパスに変更してください
    
    LineNumber = 3   ' 取得したい行番号
    StartChar = 5    ' 開始桁位置
    CharLength = 10  ' 取得する文字数
    
    ' FileSystemObjectを作成
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    ' テキストファイルを読み込みモードで開く
    Set ts = fso.OpenTextFile(FilePath, 1) ' 1は読み取り専用モード
    
    ' 指定された行に到達するまでループ
    CurrentLine = 0
    Do While Not ts.AtEndOfStream
        CurrentLine = CurrentLine + 1
        LineContent = ts.ReadLine
        
        If CurrentLine = LineNumber Then
            ' 指定桁から指定文字数分を取得
            If Len(LineContent) >= StartChar + CharLength - 1 Then
                Result = Mid(LineContent, StartChar, CharLength)
            Else
                MsgBox "指定された桁数の情報が行内に収まりません。"
                Exit Sub
            End If
            Exit Do
        End If
    Loop
    
    ' テキストストリームを閉じる
    ts.Close
    
    ' 結果を表示
    MsgBox "取得結果: " & Result
End Sub



Private Sub Form_Load()
    ' タイマー間隔を1分（60,000ミリ秒）に設定
    Me.TimerInterval = 60000
End Sub

Private Sub Form_Timer()
    ' SaveAllModulesサブルーチンを呼び出してモジュールを保存
    Call SaveAllModules
End Sub

Sub SaveAllModules()
    Dim obj As Object
    ' 全てのVBAプロジェクトアイテムをループ
    For Each obj In Application.VBE.VBProjects(1).VBComponents
        ' コードモジュールの場合のみ保存
        If obj.Type = vbext_ct_StdModule Or obj.Type = vbext_ct_ClassModule Then
            obj.Save
        End If
    Next obj
End Sub



Const vbext_ct_StdModule As Integer = 1
Const vbext_ct_ClassModule As Integer = 2

Sub SaveAllModules()
    Dim obj As Object
    ' 全てのVBAプロジェクトアイテムをループ
    For Each obj In Application.VBE.VBProjects(1).VBComponents
        ' コードモジュールの場合のみ保存
        If obj.Type = vbext_ct_StdModule Or obj.Type = vbext_ct_ClassModule Then
            obj.Save
        End If
    Next obj
End Sub


Sub CopyFolder()
    Dim fso As Object
    Dim sourceFolder As String
    Dim destinationFolder As String

    ' FileSystemObject を作成
    Set fso = CreateObject("Scripting.FileSystemObject")

    ' コピー元フォルダのパス
    sourceFolder = "C:\Path\To\SourceFolder"  ' コピー元フォルダのパスを指定

    ' コピー先フォルダのパス
    destinationFolder = "C:\Path\To\DestinationFolder"  ' コピー先フォルダのパスを指定

    ' フォルダをコピー
    If fso.FolderExists(sourceFolder) Then
        fso.CopyFolder sourceFolder, destinationFolder
        MsgBox "フォルダのコピーが完了しました！"
    Else
        MsgBox "指定されたフォルダが見つかりません。"
    End If

    ' オブジェクトの解放
    Set fso = Nothing
End Sub


Sub RunUpdateQueryWithCheck()
    Dim db As DAO.Database
    Dim sql As String
    Dim recordsAffected As Long

    ' データベースを開く
    Set db = CurrentDb

    ' SQL文を定義する
    sql = "UPDATE テーブル名 SET フィールド1 = '新しい値' WHERE 条件フィールド = '条件値'"

    On Error GoTo ErrorHandler ' エラーハンドリング

    ' SQL文を実行して影響を受けたレコード数を取得
    db.Execute sql, dbFailOnError
    recordsAffected = db.RecordsAffected

    ' 影響を受けたレコードが0の場合はエラーメッセージを表示
    If recordsAffected = 0 Then
        MsgBox "更新されたレコードがありません。条件を確認してください。", vbExclamation
    Else
        MsgBox recordsAffected & "件のレコードが更新されました。", vbInformation
    End If

    ' リソースを解放する
    Set db = Nothing
    Exit Sub

ErrorHandler:
    MsgBox "エラーが発生しました: " & Err.Description, vbCritical
End Sub



エクセルファイル
列名        データ型
------------------
ID          Long
Name        Text(50)
Birthdate   Date
Salary      Currency



Sub CreateTableFromExcel()
    Dim xlApp As Object
    Dim xlWbk As Object
    Dim xlSht As Object
    Dim db As DAO.Database
    Dim strTableName As String
    Dim strSQL As String
    Dim i As Integer
    Dim strFieldName As String
    Dim strFieldType As String

    ' Excelファイルを開く
    Set xlApp = CreateObject("Excel.Application")
    Set xlWbk = xlApp.Workbooks.Open("C:\Path\To\Your\ExcelFile.xlsx") ' Excelファイルのパスを指定
    Set xlSht = xlWbk.Sheets("Sheet1") ' シート名を指定

    ' テーブル名を設定
    strTableName = "NewTable"

    ' テーブル作成SQLの開始
    strSQL = "CREATE TABLE " & strTableName & " ("

    ' Excelの定義を取得（1行目が列名、2行目がデータ型と仮定）
    i = 2
    Do While xlSht.Cells(i, 1).Value <> ""
        strFieldName = xlSht.Cells(i, 1).Value
        strFieldType = xlSht.Cells(i, 2).Value

        ' フィールドをSQLに追加
        strSQL = strSQL & "[" & strFieldName & "] " & strFieldType & ", "
        i = i + 1
    Loop

    ' 最後のカンマを削除してSQLを完成させる
    strSQL = Left(strSQL, Len(strSQL) - 2) & ");"

    ' Accessのデータベースを開く
    Set db = CurrentDb()

    ' SQL文を実行してテーブルを作成
    db.Execute strSQL

    ' Excelを閉じる
    xlWbk.Close False
    xlApp.Quit

    ' オブジェクトを解放
    Set xlSht = Nothing
    Set xlWbk = Nothing
    Set xlApp = Nothing
    Set db = Nothing

    MsgBox "テーブルが作成されました: " & strTableName
End Sub



Sub ExportAccessModulesToExcelWithFunctionsRecursive()
    Dim accApp As Object
    Dim excelApp As Object
    Dim ws As Object
    Dim row As Integer

    ' エクセルの準備
    Set excelApp = CreateObject("Excel.Application")
    excelApp.Visible = True
    Set ws = excelApp.Workbooks.Add.Worksheets(1)
    
    ' 列のヘッダ
    ws.Cells(1, 1).Value = "FileName"
    ws.Cells(1, 2).Value = "ModuleName"
    ws.Cells(1, 3).Value = "Type" ' SubかFunctionか
    ws.Cells(1, 4).Value = "RoutineName"
    row = 2
    
    ' Access アプリケーションの準備
    Set accApp = CreateObject("Access.Application")
    
    ' フォルダを再帰的に探索してAccessファイルを処理
    Dim folderPath As String
    folderPath = "C:\path\to\your\access\files\" ' フォルダのパス
    ProcessFolder folderPath, accApp, ws, row
    
    ' クリーンアップ
    accApp.Quit
    Set accApp = Nothing
    Set excelApp = Nothing
End Sub

' フォルダを再帰的に探索してAccessファイルを処理するサブルーチン
Sub ProcessFolder(ByVal folderPath As String, ByRef accApp As Object, ByRef ws As Object, ByRef row As Integer)
    Dim fileName As String
    Dim subFolder As String
    
    ' Accessファイルを処理
    fileName = Dir(folderPath & "*.accdb") ' .accdbファイルを探す
    Do While fileName <> ""
        ProcessAccessFile folderPath & fileName, accApp, ws, row
        fileName = Dir
    Loop
    
    fileName = Dir(folderPath & "*.mdb") ' .mdbファイルを探す
    Do While fileName <> ""
        ProcessAccessFile folderPath & fileName, accApp, ws, row
        fileName = Dir
    Loop
    
    ' サブフォルダを再帰的に探索
    subFolder = Dir(folderPath & "*", vbDirectory)
    Do While subFolder <> ""
        If subFolder <> "." And subFolder <> ".." Then
            If (GetAttr(folderPath & subFolder) And vbDirectory) = vbDirectory Then
                ProcessFolder folderPath & subFolder & "\", accApp, ws, row
            End If
        End If
        subFolder = Dir
    Loop
End Sub

' Accessファイルを開いてサブルーチンと関数をエクセルに出力するサブルーチン
Sub ProcessAccessFile(ByVal filePath As String, ByRef accApp As Object, ByRef ws As Object, ByRef row As Integer)
    Dim vbComp As Object
    Dim codeModule As Object

    ' Accessファイルを開く
    accApp.OpenCurrentDatabase filePath
    
    ' モジュールをループしてサブルーチンと関数を取得
    For Each vbComp In accApp.VBE.VBProjects(1).VBComponents
        Set codeModule = vbComp.CodeModule
        If codeModule.CountOfLines > 0 Then
            ' モジュール内の各プロシージャを調べる
            Dim lineNum As Long
            For lineNum = 1 To codeModule.CountOfLines
                ' Subプロシージャを探す
                If InStr(1, codeModule.Lines(lineNum, 1), "Sub ") > 0 Then
                    Dim subName As String
                    subName = Mid(codeModule.Lines(lineNum, 1), 5, InStr(5, codeModule.Lines(lineNum, 1), "(") - 5)
                    
                    ' エクセルに書き込み
                    ws.Cells(row, 1).Value = filePath
                    ws.Cells(row, 2).Value = vbComp.Name
                    ws.Cells(row, 3).Value = "Sub"
                    ws.Cells(row, 4).Value = subName
                    row = row + 1
                End If
                
                ' Functionプロシージャを探す
                If InStr(1, codeModule.Lines(lineNum, 1), "Function ") > 0 Then
                    Dim funcName As String
                    funcName = Mid(codeModule.Lines(lineNum, 1), 10, InStr(10, codeModule.Lines(lineNum, 1), "(") - 10)
                    
                    ' エクセルに書き込み
                    ws.Cells(row, 1).Value = filePath
                    ws.Cells(row, 2).Value = vbComp.Name
                    ws.Cells(row, 3).Value = "Function"
                    ws.Cells(row, 4).Value = funcName
                    row = row + 1
                End If
            Next lineNum
        End If
    Next vbComp
End Sub



Sub SaveFormListToTable()
    Dim db As DAO.Database
    Dim rst As DAO.Recordset
    Dim obj As AccessObject
    Dim frm As AccessObject
    
    ' データベースを開く
    Set db = CurrentDb()
    
    ' テーブル「フォーム一覧」のレコードセットを開く
    Set rst = db.OpenRecordset("フォーム一覧", dbOpenDynaset)
    
    ' すべてのフォームをループして、テーブルに追加
    For Each obj In CurrentProject.AllForms
        rst.AddNew
        rst!FormName = obj.Name
        rst!DateCreated = Now ' 作成日を現在の日付で設定（任意）
        rst.Update
    Next obj
    
    ' レコードセットを閉じる
    rst.Close
    Set rst = Nothing
    Set db = Nothing
End Sub

Sub RenameAllForms()
    Dim accObj As AccessObject
    Dim oldName As String
    Dim newName As String
    Dim i As Integer
    
    ' すべてのフォームを繰り返し処理
    For i = CurrentProject.AllForms.Count - 1 To 0 Step -1
        Set accObj = CurrentProject.AllForms(i)
        oldName = accObj.Name
        
        ' すでに「frm」が付いていないか確認
        If Left(oldName, 3) <> "frm" Then
            newName = "frm" & oldName
            
            ' フォームが開いていれば閉じる
            If accObj.IsLoaded Then
                DoCmd.Close acForm, oldName, acSaveYes
            End If
            
            ' フォーム名を変更
            DoCmd.Rename newName, acForm, oldName
        End If
    Next i
End Sub


2024/10/16 15:06:36

テーブルの作成
Accessのデータベースで新しいテーブルを作成します。
以下のフィールドを追加します。
ID: オートナンバー
FileName: テキスト型（Accessファイル名）
ModuleName: テキスト型（モジュール名）
Type: テキスト型（"Sub" または "Function"）
RoutineName: テキスト型（サブルーチン名または関数名）
テーブル名を「ModuleRoutines」とします。（必要に応じて変更できますが、VBAコード内でその名前に合わせて修正する必要があります。）


Sub ExportAccessModulesToTableRecursive()
    Dim accApp As Object
    Dim db As DAO.Database
    Dim rs As DAO.Recordset
    Dim row As Integer

    ' テーブルに接続
    Set db = CurrentDb
    Set rs = db.OpenRecordset("ModuleRoutines", dbOpenDynaset) ' ModuleRoutinesはテーブル名
    
    ' Access アプリケーションの準備
    Set accApp = CreateObject("Access.Application")
    
    ' フォルダを再帰的に探索してAccessファイルを処理
    Dim folderPath As String
    folderPath = "C:\path\to\your\access\files\" ' フォルダのパス
    ProcessFolderToTable folderPath, accApp, rs
    
    ' クリーンアップ
    accApp.Quit
    rs.Close
    Set rs = Nothing
    Set db = Nothing
    Set accApp = Nothing
End Sub

' フォルダを再帰的に探索してAccessファイルを処理するサブルーチン
Sub ProcessFolderToTable(ByVal folderPath As String, ByRef accApp As Object, ByRef rs As DAO.Recordset)
    Dim fileName As String
    Dim subFolder As String
    
    ' Accessファイルを処理
    fileName = Dir(folderPath & "*.accdb") ' .accdbファイルを探す
    Do While fileName <> ""
        ProcessAccessFileToTable folderPath & fileName, accApp, rs
        fileName = Dir
    Loop
    
    fileName = Dir(folderPath & "*.mdb") ' .mdbファイルを探す
    Do While fileName <> ""
        ProcessAccessFileToTable folderPath & fileName, accApp, rs
        fileName = Dir
    Loop
    
    ' サブフォルダを再帰的に探索
    subFolder = Dir(folderPath & "*", vbDirectory)
    Do While subFolder <> ""
        If subFolder <> "." And subFolder <> ".." Then
            If (GetAttr(folderPath & subFolder) And vbDirectory) = vbDirectory Then
                ProcessFolderToTable folderPath & subFolder & "\", accApp, rs
            End If
        End If
        subFolder = Dir
    Loop
End Sub

' Accessファイルを開いてサブルーチンと関数をテーブルに出力するサブルーチン
Sub ProcessAccessFileToTable(ByVal filePath As String, ByRef accApp As Object, ByRef rs As DAO.Recordset)
    Dim vbComp As Object
    Dim codeModule As Object

    ' Accessファイルを開く
    accApp.OpenCurrentDatabase filePath
    
    ' モジュールをループしてサブルーチンと関数を取得
    For Each vbComp In accApp.VBE.VBProjects(1).VBComponents
        Set codeModule = vbComp.CodeModule
        If codeModule.CountOfLines > 0 Then
            ' モジュール内の各プロシージャを調べる
            Dim lineNum As Long
            For lineNum = 1 To codeModule.CountOfLines
                ' Subプロシージャを探す
                If InStr(1, codeModule.Lines(lineNum, 1), "Sub ") > 0 Then
                    Dim subName As String
                    subName = Mid(codeModule.Lines(lineNum, 1), 5, InStr(5, codeModule.Lines(lineNum, 1), "(") - 5)
                    
                    ' レコードをテーブルに追加
                    rs.AddNew
                    rs!FileName = filePath
                    rs!ModuleName = vbComp.Name
                    rs!Type = "Sub"
                    rs!RoutineName = subName
                    rs.Update
                End If
                
                ' Functionプロシージャを探す
                If InStr(1, codeModule.Lines(lineNum, 1), "Function ") > 0 Then
                    Dim funcName As String
                    funcName = Mid(codeModule.Lines(lineNum, 1), 10, InStr(10, codeModule.Lines(lineNum, 1), "(") - 10)
                    
                    ' レコードをテーブルに追加
                    rs.AddNew
                    rs!FileName = filePath
                    rs!ModuleName = vbComp.Name
                    rs!Type = "Function"
                    rs!RoutineName = funcName
                    rs.Update
                End If
            Next lineNum
        End If
    Next vbComp
End Sub


---------------------------------
Sub ExportAccessModulesToTableRecursive()
    Dim accApp As Object
    Dim db As DAO.Database
    Dim rs As DAO.Recordset

    ' テーブルに接続
    Set db = CurrentDb
    Set rs = db.OpenRecordset("ModuleRoutines", dbOpenDynaset) ' ModuleRoutinesはテーブル名
    
    ' Access アプリケーションの準備
    Set accApp = CreateObject("Access.Application")
    
    ' フォルダを再帰的に探索してAccessファイルを処理
    Dim folderPath As String
    folderPath = "C:\path\to\your\access\files\" ' フォルダのパス
    ProcessFolderToTable folderPath, accApp, rs
    
    ' クリーンアップ
    accApp.Quit
    rs.Close
    Set rs = Nothing
    Set db = Nothing
    Set accApp = Nothing
End Sub

' フォルダを再帰的に探索してAccessファイルを処理するサブルーチン
Sub ProcessFolderToTable(ByVal folderPath As String, ByRef accApp As Object, ByRef rs As DAO.Recordset)
    Dim fileName As String
    Dim subFolder As String

    ' Accessファイルを処理
    fileName = Dir(folderPath & "*.accdb") ' .accdbファイルを探す
    Do While fileName <> ""
        ProcessAccessFileToTable folderPath & fileName, accApp, rs
        fileName = Dir
    Loop
    
    fileName = Dir(folderPath & "*.mdb") ' .mdbファイルを探す
    Do While fileName <> ""
        ProcessAccessFileToTable folderPath & fileName, accApp, rs
        fileName = Dir
    Loop
    
    ' サブフォルダを再帰的に探索
    subFolder = Dir(folderPath, vbDirectory) ' 最初のDir呼び出しでフォルダ探索開始
    Do While subFolder <> ""
        ' "." や ".." ではないかをチェック
        If subFolder <> "." And subFolder <> ".." Then
            ' サブフォルダかどうかをチェック
            If (GetAttr(folderPath & subFolder) And vbDirectory) = vbDirectory Then
                ' 再帰的にサブフォルダを処理
                ProcessFolderToTable folderPath & subFolder & "\", accApp, rs
            End If
        End If
        subFolder = Dir ' 次のサブフォルダを取得
    Loop
End Sub

' Accessファイルを開いてサブルーチンと関数をテーブルに出力するサブルーチン
Sub ProcessAccessFileToTable(ByVal filePath As String, ByRef accApp As Object, ByRef rs As DAO.Recordset)
    Dim vbComp As Object
    Dim codeModule As Object

    ' Accessファイルを開く
    accApp.OpenCurrentDatabase filePath
    
    ' モジュールをループしてサブルーチンと関数を取得
    For Each vbComp In accApp.VBE.VBProjects(1).VBComponents
        Set codeModule = vbComp.CodeModule
        If codeModule.CountOfLines > 0 Then
            ' モジュール内の各プロシージャを調べる
            Dim lineNum As Long
            For lineNum = 1 To codeModule.CountOfLines
                ' Subプロシージャを探す
                If InStr(1, codeModule.Lines(lineNum, 1), "Sub ") > 0 Then
                    Dim subName As String
                    subName = Mid(codeModule.Lines(lineNum, 1), 5, InStr(5, codeModule.Lines(lineNum, 1), "(") - 5)
                    
                    ' レコードをテーブルに追加
                    rs.AddNew
                    rs!FileName = filePath
                    rs!ModuleName = vbComp.Name
                    rs!Type = "Sub"
                    rs!RoutineName = subName
                    rs.Update
                End If
                
                ' Functionプロシージャを探す
                If InStr(1, codeModule.Lines(lineNum, 1), "Function ") > 0 Then
                    Dim funcName As String
                    funcName = Mid(codeModule.Lines(lineNum, 1), 10, InStr(10, codeModule.Lines(lineNum, 1), "(") - 10)
                    
                    ' レコードをテーブルに追加
                    rs.AddNew
                    rs!FileName = filePath
                    rs!ModuleName = vbComp.Name
                    rs!Type = "Function"
                    rs!RoutineName = funcName
                    rs.Update
                End If
            Next lineNum
        End If
    Next vbComp
End Sub


20241017
------------
Sub subExportAccessModulesToTableWithFso()
    Dim accApp As Object
    Dim db As DAO.Database
    Dim rs As DAO.Recordset
    Dim fso As Object
    Dim folderPath As String

    ' FileSystemObjectの作成
    Set fso = CreateObject("Scripting.FileSystemObject")

    ' テーブルに接続
    Set db = CurrentDb
    Set rs = db.OpenRecordset("ModuleRoutines", dbOpenDynaset) ' ModuleRoutinesはテーブル名
    
    ' Access アプリケーションの準備
    Set accApp = CreateObject("Access.Application")
    
    ' フォルダのパスを設定
    folderPath = "C:\path\to\your\access\files\" ' フォルダのパス
    
    ' フォルダを再帰的に探索してAccessファイルを処理
    subProcessFolderWithFso fso.GetFolder(folderPath), accApp, rs

    ' クリーンアップ
    accApp.Quit
    rs.Close
    Set rs = Nothing
    Set db = Nothing
    Set accApp = Nothing
End Sub

' FileSystemObjectを使用してフォルダを再帰的に探索するサブルーチン
Sub subProcessFolderWithFso(ByVal folder As Object, ByRef accApp As Object, ByRef rs As DAO.Recordset)
    Dim file As Object
    Dim subFolder As Object

    ' Accessファイルを処理
    For Each file In folder.Files
        If Right(file.Name, 6) = ".accdb" Or Right(file.Name, 4) = ".mdb" Then
            subProcessAccessFileToTable file.Path, accApp, rs
        End If
    Next file

    ' サブフォルダを再帰的に探索
    For Each subFolder In folder.SubFolders
        subProcessFolderWithFso subFolder, accApp, rs
    Next subFolder
End Sub

' Accessファイルを開いてサブルーチンと関数をテーブルに出力するサブルーチン
Sub subProcessAccessFileToTable(ByVal filePath As String, ByRef accApp As Object, ByRef rs As DAO.Recordset)
    Dim vbComp As Object
    Dim codeModule As Object

    ' Accessファイルを開く
    accApp.OpenCurrentDatabase filePath
    
    ' モジュールをループしてサブルーチンと関数を取得
    For Each vbComp In accApp.VBE.VBProjects(1).VBComponents
        Set codeModule = vbComp.CodeModule
        If codeModule.CountOfLines > 0 Then
            ' モジュール内の各プロシージャを調べる
            Dim lineNum As Long
            For lineNum = 1 To codeModule.CountOfLines
                ' Subプロシージャを探す
                If InStr(1, codeModule.Lines(lineNum, 1), "Sub ") > 0 Then
                    Dim subName As String
                    subName = Mid(codeModule.Lines(lineNum, 1), 5, InStr(5, codeModule.Lines(lineNum, 1), "(") - 5)
                    
                    ' レコードをテーブルに追加
                    rs.AddNew
                    rs!FileName = filePath
                    rs!ModuleName = vbComp.Name
                    rs!Type = "Sub"
                    rs!RoutineName = subName
                    rs.Update
                End If
                
                ' Functionプロシージャを探す
                If InStr(1, codeModule.Lines(lineNum, 1), "Function ") > 0 Then
                    Dim fncName As String
                    fncName = Mid(codeModule.Lines(lineNum, 1), 10, InStr(10, codeModule.Lines(lineNum, 1), "(") - 10)
                    
                    ' レコードをテーブルに追加
                    rs.AddNew
                    rs!FileName = filePath
                    rs!ModuleName = vbComp.Name
                    rs!Type = "Function"
                    rs!RoutineName = fncName
                    rs.Update
                End If
            Next lineNum
        End If
    Next vbComp
End Sub


sub openExternalForm()
    ' 外部ファイルのパス
    Dim strExternalDbPath As String
    strExternalDbPath = "C:\path\to\your\external\database.accdb"
    
    ' Access Applicationオブジェクトの作成
    Dim objAccess As Object
    Set objAccess = CreateObject("Access.Application")
    
    ' 外部ファイルを開く
    objAccess.OpenCurrentDatabase strExternalDbPath
    
    ' 外部ファイル内のフォームを開く
    objAccess.DoCmd.OpenForm "yourFormName"
    
    ' Accessアプリケーションを表示
    objAccess.Visible = True
    
    ' オブジェクトの解放
    Set objAccess = Nothing
end sub


sub openExternalFormAndKeepOpen()
    ' 外部ファイルのパス
    Dim strExternalDbPath As String
    strExternalDbPath = "C:\path\to\your\external\database.accdb"
    
    ' Access Applicationオブジェクトの作成
    Dim objAccess As Object
    Set objAccess = CreateObject("Access.Application")
    
    ' 外部ファイルを開く
    objAccess.OpenCurrentDatabase strExternalDbPath
    
    ' 外部ファイル内のフォームを開く
    objAccess.DoCmd.OpenForm "yourFormName"
    
    ' Accessアプリケーションを表示
    objAccess.Visible = True
    
    ' フォームが開いた状態のまま、Accessを閉じないように待機
    Do While objAccess.CurrentProject.AllForms("yourFormName").IsLoaded
        DoEvents ' ループ中に他の操作を許可
    Loop
    
    ' オブジェクトの解放
    Set objAccess = Nothing
end sub


sub openExternalAccessAndMonitor()
    ' 外部Accessファイルのパス
    Dim strExternalDbPath As String
    strExternalDbPath = "C:\path\to\your\external\database.accdb"
    
    ' Access Applicationオブジェクトの作成
    Dim objAccess As Object
    Set objAccess = CreateObject("Access.Application")
    
    ' 外部ファイルを開く
    objAccess.OpenCurrentDatabase strExternalDbPath
    
    ' Accessアプリケーションを表示
    objAccess.Visible = True
    
    ' Accessファイルが閉じられるまで監視
    Do While Not objAccess Is Nothing
        On Error Resume Next
        ' Accessアプリケーションが閉じられたか確認
        If objAccess.CurrentProject Is Nothing Then
            Exit Do ' Accessが閉じられた
        End If
        On Error GoTo 0
        DoEvents ' 他の操作を受け付けるために必要
    Loop
    
    ' オブジェクトの解放
    Set objAccess = Nothing
end sub




Sub runExternalSub()
    Dim accApp As Access.Application
    Set accApp = New Access.Application
    
    ' 外部のデータベースファイルを開く
    accApp.OpenCurrentDatabase "C:\path\to\ExternalDB.accdb"
    
    ' 外部データベース内のサブルーチンを実行
    accApp.Run "subExternalRoutine"
    
    ' データベースを閉じる
    accApp.CloseCurrentDatabase
    Set accApp = Nothing
End Sub



Sub subGetFilteredRecordSet()
    Dim db As DAO.Database
    Dim rs As DAO.Recordset
    Dim strSql As String
    Dim strCondition As String

    ' データベースへの参照を取得
    Set db = CurrentDb
    
    ' 抽出条件を指定 (例: IDが100以上)
    strCondition = "WHERE ID >= 100"
    
    ' SQL文の作成
    strSql = "SELECT * FROM YourTableName " & strCondition
    
    ' レコードセットを取得
    Set rs = db.OpenRecordset(strSql)
    
    ' レコードセットを処理 (例: デバッグ出力に表示)
    If Not rs.EOF Then
        rs.MoveFirst
        Do Until rs.EOF
            Debug.Print rs!FieldName  ' フィールド名に置き換えてください
            rs.MoveNext
        Loop
    End If
    
    ' レコードセットとデータベースを閉じる
    rs.Close
    Set rs = Nothing
    Set db = Nothing
End Sub





Sub ProcessAccessFileToTable(ByVal filePath As String, ByRef accApp As Object, ByRef rs As DAO.Recordset)
    Dim vbComp As Object
    Dim codeModule As Object

    ' 既にデータベースが開かれている場合は閉じる
    If accApp.CurrentDb Is Nothing = False Then
        accApp.CloseCurrentDatabase
    End If

    ' Accessファイルを開く
    accApp.OpenCurrentDatabase filePath
    
    ' モジュールをループしてサブルーチンと関数を取得
    For Each vbComp In accApp.VBE.VBProjects(1).VBComponents
        Set codeModule = vbComp.CodeModule
        If codeModule.CountOfLines > 0 Then
            ' モジュール内の各プロシージャを調べる
            Dim lineNum As Long
            For lineNum = 1 To codeModule.CountOfLines
                Dim currentLine As String
                currentLine = Trim(codeModule.Lines(lineNum, 1))

                ' Subプロシージャを探す
                If InStr(1, currentLine, "Sub ") > 0 Then
                    Dim subName As String
                    subName = ExtractRoutineName(currentLine, "Sub")
                    
                    ' レコードをテーブルに追加
                    rs.AddNew
                    rs!FileName = filePath
                    rs!ModuleName = vbComp.Name
                    rs!Type = "Sub"
                    rs!RoutineName = subName
                    rs.Update
                End If
                
                ' Functionプロシージャを探す
                If InStr(1, currentLine, "Function ") > 0 Then
                    Dim funcName As String
                    funcName = ExtractRoutineName(currentLine, "Function")
                    
                    ' レコードをテーブルに追加
                    rs.AddNew
                    rs!FileName = filePath
                    rs!ModuleName = vbComp.Name
                    rs!Type = "Function"
                    rs!RoutineName = funcName
                    rs.Update
                End If
            Next lineNum
        End If
    Next vbComp
End Sub

' Sub または Function 名を抽出するための関数
Function ExtractRoutineName(ByVal codeLine As String, ByVal routineType As String) As String
    Dim nameStart As Long
    Dim nameEnd As Long
    Dim routineName As String
    
    ' サブルーチンや関数名の開始位置を決定 (Sub または Function の後)
    nameStart = InStr(1, codeLine, routineType) + Len(routineType) + 1 ' Sub/Functionの後にあるスペースを考慮
    
    ' 開始括弧 "(" の前までを取得
    nameEnd = InStr(nameStart, codeLine, "(")
    
    ' サブルーチン/関数名を抽出
    If nameEnd > 0 Then
        routineName = Trim(Mid(codeLine, nameStart, nameEnd - nameStart))
    Else
        ' "(" がない場合、行全体を切り取る
        routineName = Trim(Mid(codeLine, nameStart))
    End If
    
    ExtractRoutineName = routineName
End Function



Sub subGetTablesFromAccessFiles()
    Dim strFolderPath As String
    Dim objFSO As Object
    Dim objFolder As Object
    Dim objFile As Object
    Dim objDb As DAO.Database
    Dim objTableDef As DAO.TableDef
    Dim objCurrentDb As DAO.Database
    Dim rst As DAO.Recordset
    Dim strTblName As String
    Dim newTableDef As DAO.TableDef
    Dim newField As DAO.Field
    
    ' 処理するフォルダのパスを指定
    strFolderPath = "C:\Path\To\Your\Folder\" ' <- ここを適宜変更してください

    ' FileSystemObject を作成
    Set objFSO = CreateObject("Scripting.FileSystemObject")
    Set objFolder = objFSO.GetFolder(strFolderPath)

    ' 現在のデータベースを参照
    Set objCurrentDb = CurrentDb
    
    ' 新しいテーブル "tblTablesList" を作成（存在する場合は一度削除）
    On Error Resume Next
    objCurrentDb.TableDefs.Delete "tblTablesList"
    On Error GoTo 0
    
    ' 新しいテーブルの作成
    Set newTableDef = objCurrentDb.CreateTableDef("tblTablesList")
    
    ' フィールドの作成
    Set newField = newTableDef.CreateField("FileName", dbText, 255)
    newTableDef.Fields.Append newField
    Set newField = newTableDef.CreateField("TableName", dbText, 255)
    newTableDef.Fields.Append newField
    
    ' テーブルの追加
    objCurrentDb.TableDefs.Append newTableDef

    ' tblTablesList テーブルの Recordset をオープン
    Set rst = objCurrentDb.OpenRecordset("tblTablesList", dbOpenDynaset)
    
    ' フォルダ内のすべてのファイルをループ
    For Each objFile In objFolder.Files
        ' Accessファイル (.accdb または .mdb) のみ処理
        If objFSO.GetExtensionName(objFile.Name) = "accdb" Or objFSO.GetExtensionName(objFile.Name) = "mdb" Then
            ' 各ファイルを開いてテーブル名を取得
            Set objDb = OpenDatabase(objFile.Path)
            For Each objTableDef In objDb.TableDefs
                ' システムテーブル以外を取得
                If Left(objTableDef.Name, 4) <> "MSys" Then
                    strTblName = objTableDef.Name
                    ' レコードを追加
                    rst.AddNew
                    rst!FileName = objFile.Name
                    rst!TableName = strTblName
                    rst.Update
                End If
            Next objTableDef
            objDb.Close
        End If
    Next objFile

    ' Recordset を閉じる
    rst.Close

    MsgBox "テーブル一覧の取得が完了しました。", vbInformation

    ' 後処理
    Set rst = Nothing
    Set objDb = Nothing
    Set objCurrentDb = Nothing
    Set objFSO = Nothing
    Set objFolder = Nothing
End Sub




-----------------------------
!!!!!!!!!!!!!!!!!!

Sub subAddAutoNumberToAllTables()
    Dim objFso As Object
    Dim objFolder As Object
    Dim objFile As Object
    Dim objDb As DAO.Database
    Dim tblDef As DAO.TableDef
    Dim fld As DAO.Field
    Dim strFolderPath As String
    Dim strFilePath As String
    Dim strTableName As String
    Dim blnFieldExists As Boolean

    ' 処理するフォルダパスを指定
    strFolderPath = "C:\path\to\folder\" ' フォルダのパスを指定

    ' FileSystemObjectの初期化
    Set objFso = CreateObject("Scripting.FileSystemObject")
    Set objFolder = objFso.GetFolder(strFolderPath)

    ' フォルダ内のすべてのファイルをループ
    For Each objFile In objFolder.Files
        ' 拡張子が.accdbのファイルのみ処理
        If objFso.GetExtensionName(objFile.Name) = "accdb" Then
            strFilePath = objFolder.Path & "\" & objFile.Name
            
            ' データベースを開く
            Set objDb = OpenDatabase(strFilePath)
            
            ' データベース内のすべてのテーブルをループ
            For Each tblDef In objDb.TableDefs
                ' システムテーブルはスキップ
                If Left(tblDef.Name, 4) <> "MSys" Then
                    blnFieldExists = False
                    
                    ' テーブル内のフィールドをチェックしてIDフィールドがあるか確認
                    For Each fld In tblDef.Fields
                        If fld.Name = "ID" Then
                            blnFieldExists = True
                            Exit For
                        End If
                    Next fld
                    
                    ' IDフィールドがない場合に追加
                    If Not blnFieldExists Then
                        objDb.Execute "ALTER TABLE [" & tblDef.Name & "] ADD COLUMN ID COUNTER(1,1);", dbFailOnError
                        Debug.Print "IDフィールドを追加しました: " & tblDef.Name
                    End If
                End If
            Next tblDef
            
            ' データベースを閉じる
            objDb.Close
        End If
    Next objFile
    
    ' オブジェクトの解放
    Set objDb = Nothing
    Set objFso = Nothing
    Set objFolder = Nothing
    
    MsgBox "すべてのテーブルにIDフィールドの追加が完了しました。", vbInformation
End Sub



Sub subAddAutoNumberFieldWithoutPrimaryKey()
    Dim objFso As Object
    Dim objFolder As Object
    Dim objFile As Object
    Dim objDb As DAO.Database
    Dim tblDef As DAO.TableDef
    Dim fld As DAO.Field
    Dim strFolderPath As String
    Dim strFilePath As String
    Dim blnFieldExists As Boolean

    ' 処理するフォルダパスを指定
    strFolderPath = "C:\path\to\folder\" ' フォルダのパスを指定

    ' FileSystemObjectの初期化
    Set objFso = CreateObject("Scripting.FileSystemObject")
    Set objFolder = objFso.GetFolder(strFolderPath)

    ' フォルダ内のすべてのファイルをループ
    For Each objFile In objFolder.Files
        ' 拡張子が.accdbのファイルのみ処理
        If objFso.GetExtensionName(objFile.Name) = "accdb" Then
            strFilePath = objFolder.Path & "\" & objFile.Name
            
            ' データベースを開く
            Set objDb = OpenDatabase(strFilePath)
            
            ' データベース内のすべてのテーブルをループ
            For Each tblDef In objDb.TableDefs
                ' システムテーブルはスキップ
                If Left(tblDef.Name, 4) <> "MSys" Then
                    blnFieldExists = False
                    
                    ' テーブル内のフィールドをチェックしてIDフィールドがあるか確認
                    For Each fld In tblDef.Fields
                        If fld.Name = "ID" Then
                            blnFieldExists = True
                            Exit For
                        End If
                    Next fld
                    
                    ' IDフィールドがない場合に追加
                    If Not blnFieldExists Then
                        ' フィールドオブジェクトを作成
                        Set fld = tblDef.CreateField("ID", dbLong)
                        fld.Attributes = dbAutoIncrField ' オートナンバー型を指定
                        
                        ' テーブルにフィールドを追加
                        tblDef.Fields.Append fld
                        Debug.Print "IDフィールドを追加しました: " & tblDef.Name
                    End If
                End If
            Next tblDef
            
            ' データベースを閉じる
            objDb.Close
        End If
    Next objFile
    
    ' オブジェクトの解放
    Set objDb = Nothing
    Set objFso = Nothing
    Set objFolder = Nothing
    
    MsgBox "すべてのテーブルにIDフィールドの追加が完了しました（主キーなし）。", vbInformation
End Sub


' 重複なしインデックスの作成
                        Set idx = tblDef.CreateIndex("UniqueIDIndex")
                        idx.Fields.Append idx.CreateField("ID")
                        idx.Unique = True ' インデックスを一意制約として設定
                        
                        ' インデックスをテーブルに追加
                        tblDef.Indexes.Append idx
                        Debug.Print "IDフィールドに重複なしインデックスを追加しました: " & tblDef.Name
                        
                        
                        
                        
Sub subGetAllTablesFromFolderWithoutExecute()
    Dim fso As Object
    Dim fld As Object
    Dim fil As Object
    Dim dbExternal As DAO.Database
    Dim dbCurrent As DAO.Database
    Dim tblDef As DAO.TableDef
    Dim rst As DAO.Recordset
    Dim strFolderPath As String

    ' フォルダパスの指定
    strFolderPath = "C:\Your\Folder\Path\" ' ここにフォルダのパスを指定してください
    
    ' FileSystemObjectの作成
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set fld = fso.GetFolder(strFolderPath)
    
    ' 現在のデータベースを参照
    Set dbCurrent = CurrentDb
    
    ' 結果格納用のテーブルを作成（必要に応じて削除して再作成）
    On Error Resume Next
    Set rst = dbCurrent.OpenRecordset("tblAllTablesInFolder")
    If rst Is Nothing Then
        ' テーブルが存在しない場合、新規作成
        dbCurrent.CreateTableDef "tblAllTablesInFolder"
        dbCurrent.Execute "CREATE TABLE tblAllTablesInFolder (FileName TEXT(255), TableName TEXT(255))"
        Set rst = dbCurrent.OpenRecordset("tblAllTablesInFolder")
    End If
    On Error GoTo 0
    
    ' フォルダ内のすべてのファイルをループ
    For Each fil In fld.Files
        ' Accessファイルのみを処理
        If fso.GetExtensionName(fil.Name) = "accdb" Or fso.GetExtensionName(fil.Name) = "mdb" Then
            ' 外部データベースに接続
            Set dbExternal = OpenDatabase(fil.Path)
            
            ' 外部データベース内のすべてのテーブルを取得
            For Each tblDef In dbExternal.TableDefs
                ' システムテーブルを除外
                If Left(tblDef.Name, 4) <> "MSys" Then
                    ' Recordsetを使ってデータを追加
                    rst.AddNew
                    rst!FileName = fil.Name
                    rst!TableName = tblDef.Name
                    rst.Update
                End If
            Next tblDef
            
            ' 外部データベースを閉じる
            dbExternal.Close
        End If
    Next fil
    
    ' Recordsetを閉じる
    rst.Close
    
    MsgBox "指定フォルダ内のすべてのテーブルが取得されました。", vbInformation
End Sub













Sub subOptimizeAllAccessFilesWithSizeTracking()
    ' フォルダパスを指定
    Dim strFolderPath As String
    Dim objFSO As Object
    Dim objFolder As Object
    Dim objFile As Object
    Dim appAccess As Object
    Dim strFilePath As String
    Dim lngSizeBefore As Long
    Dim lngSizeAfter As Long
    Dim rs As DAO.Recordset
    Dim db As DAO.Database
    
    ' フォルダパスをここに設定
    strFolderPath = "C:\Path\To\AccessFiles" ' フォルダのパスを設定
    
    ' FileSystemObjectを使用してフォルダ内のファイルを取得
    Set objFSO = CreateObject("Scripting.FileSystemObject")
    Set objFolder = objFSO.GetFolder(strFolderPath)
    
    ' Accessアプリケーションオブジェクトを作成
    Set appAccess = CreateObject("Access.Application")
    
    ' 現在のデータベースを開き、テーブルを操作
    Set db = CurrentDb
    Set rs = db.OpenRecordset("tblFileOptimization")
    
    ' フォルダ内のすべてのファイルをループ
    For Each objFile In objFolder.Files
        ' Accessファイルのみを処理（.accdb または .mdb）
        If objFSO.GetExtensionName(objFile.Name) = "accdb" Or objFSO.GetExtensionName(objFile.Name) = "mdb" Then
            strFilePath = objFile.Path
            Debug.Print "Optimizing: " & strFilePath
            
            ' 最適化前のファイルサイズを取得
            lngSizeBefore = objFile.Size
            
            ' Accessファイルを開く
            appAccess.OpenCurrentDatabase strFilePath
            
            ' ファイルを圧縮と修復
            appAccess.CloseCurrentDatabase
            appAccess.DBEngine.CompactDatabase strFilePath, strFilePath
            
            ' 最適化後のファイルサイズを取得
            lngSizeAfter = objFSO.GetFile(strFilePath).Size
            
            ' 結果をテーブルに記録
            With rs
                .AddNew
                !FileName = objFile.Name
                !FilePath = strFilePath
                !SizeBefore = lngSizeBefore
                !SizeAfter = lngSizeAfter
                !DateOptimized = Now
                .Update
            End With
            
            Debug.Print "Optimized: " & strFilePath & " | Size Before: " & lngSizeBefore & " | Size After: " & lngSizeAfter
        End If
    Next objFile
    
    ' リソース解放
    rs.Close
    Set rs = Nothing
    Set db = Nothing
    appAccess.Quit
    Set appAccess = Nothing
    Set objFSO = Nothing
End Sub





Sub subOptimizeAllAccessFilesWithSizeTracking()
    ' フォルダパスを指定
    Dim strFolderPath As String
    Dim objFSO As Object
    Dim objFolder As Object
    Dim objFile As Object
    Dim appAccess As Object
    Dim strFilePath As String
    Dim strTempFilePath As String
    Dim lngSizeBefore As Long
    Dim lngSizeAfter As Long
    Dim rs As DAO.Recordset
    Dim db As DAO.Database
    
    ' フォルダパスをここに設定
    strFolderPath = "C:\Path\To\AccessFiles" ' フォルダのパスを設定
    
    ' FileSystemObjectを使用してフォルダ内のファイルを取得
    Set objFSO = CreateObject("Scripting.FileSystemObject")
    Set objFolder = objFSO.GetFolder(strFolderPath)
    
    ' Accessアプリケーションオブジェクトを作成
    Set appAccess = CreateObject("Access.Application")
    
    ' 現在のデータベースを開き、テーブルを操作
    Set db = CurrentDb
    Set rs = db.OpenRecordset("tblFileOptimization")
    
    ' フォルダ内のすべてのファイルをループ
    For Each objFile In objFolder.Files
        ' Accessファイルのみを処理（.accdb または .mdb）
        If objFSO.GetExtensionName(objFile.Name) = "accdb" Or objFSO.GetExtensionName(objFile.Name) = "mdb" Then
            strFilePath = objFile.Path
            strTempFilePath = objFile.Path & "_temp"
            
            Debug.Print "Optimizing: " & strFilePath
            
            ' 最適化前のファイルサイズを取得
            lngSizeBefore = objFile.Size
            
            ' Accessファイルを開く
            appAccess.OpenCurrentDatabase strFilePath
            
            ' ファイルを閉じる
            appAccess.CloseCurrentDatabase
            
            ' ファイルを圧縮し、一時ファイルに保存
            appAccess.DBEngine.CompactDatabase strFilePath, strTempFilePath
            
            ' 元のファイルを削除し、一時ファイルを元の場所にリネーム
            objFSO.DeleteFile strFilePath
            objFSO.MoveFile strTempFilePath, strFilePath
            
            ' 最適化後のファイルサイズを取得
            lngSizeAfter = objFSO.GetFile(strFilePath).Size
            
            ' 結果をテーブルに記録
            With rs
                .AddNew
                !FileName = objFile.Name
                !FilePath = strFilePath
                !SizeBefore = lngSizeBefore
                !SizeAfter = lngSizeAfter
                !DateOptimized = Now
                .Update
            End With
            
            Debug.Print "Optimized: " & strFilePath & " | Size Before: " & lngSizeBefore & " | Size After: " & lngSizeAfter
        End If
    Next objFile
    
    ' リソース解放
    rs.Close
    Set rs = Nothing
    Set db = Nothing
    appAccess.Quit
    Set appAccess = Nothing
    Set objFSO = Nothing
End Sub



20241024-------------


Sub subLinkAllAccessFilesInFolder()
    Dim objFSO As Object
    Dim objFolder As Object
    Dim objFile As Object
    Dim strFolderPath As String
    Dim dbCurrent As DAO.Database
    Dim dbExternal As DAO.Database
    Dim strExternalDbPath As String
    Dim strTableName As String
    Dim tdfLinked As DAO.TableDef

    ' フォルダパスを指定
    strFolderPath = "C:\YourFolderPath" ' ここにフォルダパスを指定

    ' FileSystemObjectを作成
    Set objFSO = CreateObject("Scripting.FileSystemObject")
    Set objFolder = objFSO.GetFolder(strFolderPath)
    Set dbCurrent = CurrentDb

    ' フォルダ内の各ファイルを処理
    For Each objFile In objFolder.Files
        If objFSO.GetExtensionName(objFile.Name) = "accdb" Or objFSO.GetExtensionName(objFile.Name) = "mdb" Then
            strExternalDbPath = objFile.Path
            Set dbExternal = DBEngine.OpenDatabase(strExternalDbPath)

            ' 外部データベース内のすべてのテーブルをリンク
            For Each tdfLinked In dbExternal.TableDefs
                If Not tdfLinked.Name Like "MSys*" Then
                    strTableName = tdfLinked.Name
                    On Error Resume Next
                    ' テーブルのリンクを作成
                    Set tdfLinked = dbCurrent.CreateTableDef(strTableName)
                    tdfLinked.Connect = ";DATABASE=" & strExternalDbPath
                    tdfLinked.SourceTableName = strTableName
                    dbCurrent.TableDefs.Append tdfLinked
                    On Error GoTo 0
                End If
            Next tdfLinked
            dbExternal.Close
        End If
    Next objFile

    ' 後処理
    Set objFolder = Nothing
    Set objFSO = Nothing
    Set dbCurrent = Nothing
    MsgBox "リンク作成が完了しました。"
End Sub




77777777777777777777777777777
Sub subGetFilesAndSaveToTable(strFolderPath As String)
    ' サブフォルダを含むすべてのファイル名、ファイルサイズ、タイムスタンプを取得してテーブルに保存する
    Dim objFileSystem As Object
    Dim objFolder As Object
    Dim objSubFolder As Object
    Dim objFile As Object
    Dim rs As DAO.Recordset

    ' FileSystemObjectの作成
    Set objFileSystem = CreateObject("Scripting.FileSystemObject")
    Set objFolder = objFileSystem.GetFolder(strFolderPath)

    ' テーブルにデータを追加するためのRecordsetを開く
    Set rs = CurrentDb.OpenRecordset("tblFiles", dbOpenDynaset)

    ' ファイルをテーブルに保存する処理
    For Each objFile In objFolder.Files
        rs.AddNew
        rs!FileName = objFile.Name
        rs!FilePath = objFile.Path
        rs!FileSize = objFile.Size ' ファイルサイズを取得 (バイト単位)
        rs!LastModified = objFile.DateLastModified ' ファイルの最終更新日時を取得
        rs.Update
    Next objFile

    ' サブフォルダがある場合は再帰的に処理
    For Each objSubFolder In objFolder.SubFolders
        subGetFilesAndSaveToTable objSubFolder.Path
    Next objSubFolder

    ' オブジェクトのクリーンアップ
    rs.Close
    Set rs = Nothing
    Set objFile = Nothing
    Set objFolder = Nothing
    Set objFileSystem = Nothing
End Sub

Sub subStartFileImport()
    ' 開始フォルダを指定して再帰処理を開始するサブプロシージャ
    Dim strStartFolder As String
    strStartFolder = "C:\Your\Start\Folder\Path" ' ここにフォルダパスを入力

    ' テーブルの内容をクリア
    Dim rs As DAO.Recordset
    Set rs = CurrentDb.OpenRecordset("tblFiles", dbOpenDynaset)
    Do While Not rs.EOF
        rs.Delete
        rs.MoveNext
    Loop
    rs.Close
    Set rs = Nothing

    ' ファイルを取得してテーブルに保存
    subGetFilesAndSaveToTable strStartFolder
End Sub



Sub subFindAndConcat()
    Dim strTarget As String
    Dim strResult As String
    Dim wsSource As Worksheet
    Dim wsSearch As Worksheet
    Dim lngLastRow As Long
    Dim i As Long

    ' シートを指定
    Set wsSource = ThisWorkbook.Sheets("Sheet1") ' 検索元シート
    Set wsSearch = ThisWorkbook.Sheets("Sheet2") ' 検索対象シート

    ' 検索する値を取得
    strTarget = wsSource.Range("A1").Value

    ' 検索対象シートの最終行を取得
    lngLastRow = wsSearch.Cells(wsSearch.Rows.Count, "A").End(xlUp).Row

    ' 結果初期化
    strResult = ""

    ' 検索対象シートの列Aで値を検索し、隣の列Bの値をカンマで連結
    For i = 1 To lngLastRow
        If wsSearch.Cells(i, 1).Value = strTarget Then
            If strResult <> "" Then
                strResult = strResult & ", "
            End If
            strResult = strResult & wsSearch.Cells(i, 2).Value
        End If
    Next i

    ' 結果をシート1のセルB1に表示
    wsSource.Range("B1").Value = strResult
End Sub


Function fncFindAndConcat(targetCell As Range) As String
    Dim strTarget As String
    Dim strResult As String
    Dim wsSearch As Worksheet
    Dim lngLastRow As Long
    Dim i As Long

    ' 検索対象のシートを指定
    Set wsSearch = ThisWorkbook.Sheets("Sheet2") ' 検索対象シート

    ' 検索する値を取得
    strTarget = targetCell.Value

    ' 検索対象シートの最終行を取得
    lngLastRow = wsSearch.Cells(wsSearch.Rows.Count, "A").End(xlUp).Row

    ' 結果初期化
    strResult = ""

    ' 検索対象シートの列Aで値を検索し、隣の列Bの値をカンマで連結
    For i = 1 To lngLastRow
        If wsSearch.Cells(i, 1).Value = strTarget Then
            If strResult <> "" Then
                strResult = strResult & ", "
            End If
            strResult = strResult & wsSearch.Cells(i, 2).Value
        End If
    Next i

    ' 結果を関数の戻り値として返す
    fncFindAndConcat = strResult
End Function


    If Not Intersect(Target, Me.Range("A1:A10")) Is Nothing Then
        ' UDFが含まれているセルの再計算
        Application.Calculate
    End If
    
    
    
    
    
Sub prcExportErrorListToCSV()
    Dim intErrorCode As Integer
    Dim strErrorDescription As String
    Dim strFilePath As String
    Dim intFileNumber As Integer
    
    ' CSVファイルの保存先とファイル名
    strFilePath = "C:\YourPath\Access_VBA_Error_List.csv"
    intFileNumber = FreeFile
    
    ' CSVファイルの書き込み準備
    Open strFilePath For Output As intFileNumber
    Print #intFileNumber, "エラーコード,エラー内容" ' ヘッダー行の追加
    
    ' エラー一覧を取得してCSVに書き込み
    For intErrorCode = 1 To 1000 ' 必要な範囲まで拡張可能
        On Error Resume Next
        Err.Raise intErrorCode
        If Err.Number <> 0 Then
            strErrorDescription = Err.Description
            Err.Clear
            
            ' エラーコードと内容をCSVに書き込み
            Print #intFileNumber, intErrorCode & "," & strErrorDescription
        End If
        On Error GoTo 0
    Next intErrorCode
    
    ' ファイルを閉じる
    Close intFileNumber
    
    MsgBox "エラー一覧がCSVファイルに出力されました: " & strFilePath, vbInformation
End Sub


Sub exportNestedDictionaryToCSV_FSO()
    Dim fso As Object
    Dim csvFile As Object
    Dim mainDict As Object
    Dim subDict As Object
    Dim key As Variant
    Dim subKey As Variant
    Dim filePath As String
    
    ' CSVファイルのパスを指定
    filePath = "C:\path\to\your\file.csv"  ' 保存するパスに変更してください

    ' FileSystemObjectとファイルを作成
    Set fso = CreateObject("Scripting.FileSystemObject")
    Set csvFile = fso.CreateTextFile(filePath, True, True) ' 第2引数で上書きを許可
    
    ' メインのディクショナリを作成
    Set mainDict = CreateObject("Scripting.Dictionary")

    ' サブディクショナリ1を作成し、キーと値を追加
    Set subDict = CreateObject("Scripting.Dictionary")
    subDict.Add "SubKey1", "SubValue1"
    subDict.Add "SubKey2", "SubValue2"
    mainDict.Add "MainKey1", subDict

    ' サブディクショナリ2を作成し、キーと値を追加
    Set subDict = CreateObject("Scripting.Dictionary")
    subDict.Add "SubKeyA", "SubValueA"
    subDict.Add "SubKeyB", "SubValueB"
    mainDict.Add "MainKey2", subDict

    ' CSVのヘッダーを書き込む
    csvFile.WriteLine "MainKey,SubKey,Value"
    
    ' メインディクショナリの内容をCSVに書き込む
    For Each key In mainDict.Keys
        Set subDict = mainDict(key)  ' サブディクショナリを取得
        For Each subKey In subDict.Keys
            csvFile.WriteLine key & "," & subKey & "," & subDict(subKey)
        Next subKey
    Next key

    ' ファイルを閉じる
    csvFile.Close

    MsgBox "CSVファイルが作成されました: " & filePath
End Sub

    
    
    
    
    
 #If VBA7 Then
    Private Declare PtrSafe Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As LongPtr
    Private Declare PtrSafe Function GetExitCodeProcess Lib "kernel32" (ByVal hProcess As LongPtr, lpExitCode As Long) As Long
    Private Declare PtrSafe Function CloseHandle Lib "kernel32" (ByVal hObject As LongPtr) As Long
#Else
    Private Declare Function OpenProcess Lib "kernel32" (ByVal dwDesiredAccess As Long, ByVal bInheritHandle As Long, ByVal dwProcessId As Long) As Long
    Private Declare Function GetExitCodeProcess Lib "kernel32" (ByVal hProcess As Long, lpExitCode As Long) As Long
    Private Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
#End If

Private Const PROCESS_QUERY_INFORMATION = &H400
Private Const STILL_ACTIVE = &H103

sub openExternalAccessAndGetProcessId()
    Dim strExternalDbPath As String
    Dim objAccess As Object
    Dim lngProcessId As Long
    Dim hProcess As LongPtr
    Dim lngExitCode As Long
    
    ' 外部ファイルのパス
    strExternalDbPath = "C:\path\to\your\external\database.accdb"
    
    ' Access Applicationオブジェクトの作成
    Set objAccess = CreateObject("Access.Application")
    
    ' 外部ファイルを開く
    objAccess.OpenCurrentDatabase strExternalDbPath
    
    ' Accessアプリケーションを表示
    objAccess.Visible = True
    
    ' AccessプロセスのIDを取得
    lngProcessId = objAccess.hWndAccessApp
    
    ' プロセスのハンドルを取得
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, False, lngProcessId)
    
    ' プロセスが終了するまで待機
    Do
        ' プロセスの終了コードを取得
        Call GetExitCodeProcess(hProcess, lngExitCode)
        
        ' プロセスがまだアクティブか確認
        If lngExitCode <> STILL_ACTIVE Then
            Exit Do ' プロセスが終了
        End If
        
        DoEvents ' 他の操作を受け付ける
    Loop
    
    ' プロセスハンドルを閉じる
    CloseHandle hProcess
    
    ' オブジェクトの解放
    Set objAccess = Nothing
end sub

    